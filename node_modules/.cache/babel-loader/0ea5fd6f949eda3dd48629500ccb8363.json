{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst nextTick = require(\"process\").nextTick;\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n\n\nconst dirname = path => {\n  let idx = path.length - 1;\n\n  while (idx >= 0) {\n    const c = path.charCodeAt(idx); // slash or backslash\n\n    if (c === 47 || c === 92) break;\n    idx--;\n  }\n\n  if (idx < 0) return \"\";\n  return path.slice(0, idx);\n};\n\nconst runCallbacks = (callbacks, err, result) => {\n  if (callbacks.length === 1) {\n    callbacks[0](err, result);\n    callbacks.length = 0;\n    return;\n  }\n\n  let error;\n\n  for (const callback of callbacks) {\n    try {\n      callback(err, result);\n    } catch (e) {\n      if (!error) error = e;\n    }\n  }\n\n  callbacks.length = 0;\n  if (error) throw error;\n};\n\nclass OperationMergerBackend {\n  /**\r\n   * @param {any} provider async method\r\n   * @param {any} syncProvider sync method\r\n   * @param {any} providerContext call context for the provider methods\r\n   */\n  constructor(provider, syncProvider, providerContext) {\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    this._activeAsyncOperations = new Map();\n    this.provide = this._provider ? (path, options, callback) => {\n      if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n      }\n\n      if (options) {\n        return this._provider.call(this._providerContext, path, options, callback);\n      }\n\n      if (typeof path !== \"string\") {\n        callback(new TypeError(\"path must be a string\"));\n        return;\n      }\n\n      let callbacks = this._activeAsyncOperations.get(path);\n\n      if (callbacks) {\n        callbacks.push(callback);\n        return;\n      }\n\n      this._activeAsyncOperations.set(path, callbacks = [callback]);\n\n      provider(path, (err, result) => {\n        this._activeAsyncOperations.delete(path);\n\n        runCallbacks(callbacks, err, result);\n      });\n    } : null;\n    this.provideSync = this._syncProvider ? (path, options) => {\n      return this._syncProvider.call(this._providerContext, path, options);\n    } : null;\n  }\n\n  purge() {}\n\n  purgeParent() {}\n\n}\n/*\r\n\r\nIDLE:\r\n\tinsert data: goto SYNC\r\n\r\nSYNC:\r\n\tbefore provide: run ticks\r\n\tevent loop tick: goto ASYNC_ACTIVE\r\n\r\nASYNC:\r\n\ttimeout: run tick, goto ASYNC_PASSIVE\r\n\r\nASYNC_PASSIVE:\r\n\tbefore provide: run ticks\r\n\r\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\r\n                                                          ^                             |\r\n                                                          +---------[insert data]-------+\r\n*/\n\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\nclass CacheBackend {\n  /**\r\n   * @param {number} duration max cache duration of items\r\n   * @param {any} provider async method\r\n   * @param {any} syncProvider sync method\r\n   * @param {any} providerContext call context for the provider methods\r\n   */\n  constructor(duration, provider, syncProvider, providerContext) {\n    this._duration = duration;\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    /** @type {Map<string, (function(Error, any): void)[]>} */\n\n    this._activeAsyncOperations = new Map();\n    /** @type {Map<string, { err: Error, result: any, level: Set<string> }>} */\n\n    this._data = new Map();\n    /** @type {Set<string>[]} */\n\n    this._levels = [];\n\n    for (let i = 0; i < 10; i++) this._levels.push(new Set());\n\n    for (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n\n    this._currentLevel = 0;\n    this._tickInterval = Math.floor(duration / this._levels.length);\n    /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n\n    this._mode = STORAGE_MODE_IDLE;\n    /** @type {NodeJS.Timeout | undefined} */\n\n    this._timeout = undefined;\n    /** @type {number | undefined} */\n\n    this._nextDecay = undefined;\n    this.provide = provider ? this.provide.bind(this) : null;\n    this.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n  }\n\n  provide(path, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof path !== \"string\") {\n      callback(new TypeError(\"path must be a string\"));\n      return;\n    }\n\n    if (options) {\n      return this._provider.call(this._providerContext, path, options, callback);\n    } // When in sync mode we can move to async mode\n\n\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._enterAsyncMode();\n    } // Check in cache\n\n\n    let cacheEntry = this._data.get(path);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n      return nextTick(callback, null, cacheEntry.result);\n    } // Check if there is already the same operation running\n\n\n    let callbacks = this._activeAsyncOperations.get(path);\n\n    if (callbacks !== undefined) {\n      callbacks.push(callback);\n      return;\n    }\n\n    this._activeAsyncOperations.set(path, callbacks = [callback]); // Run the operation\n\n\n    this._provider.call(this._providerContext, path, (err, result) => {\n      this._activeAsyncOperations.delete(path);\n\n      this._storeResult(path, err, result); // Enter async mode if not yet done\n\n\n      this._enterAsyncMode();\n\n      runCallbacks(callbacks, err, result);\n    });\n  }\n\n  provideSync(path, options) {\n    if (typeof path !== \"string\") {\n      throw new TypeError(\"path must be a string\");\n    }\n\n    if (options) {\n      return this._syncProvider.call(this._providerContext, path, options);\n    } // In sync mode we may have to decay some cache items\n\n\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._runDecays();\n    } // Check in cache\n\n\n    let cacheEntry = this._data.get(path);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) throw cacheEntry.err;\n      return cacheEntry.result;\n    } // Get all active async operations\n    // This sync operation will also complete them\n\n\n    const callbacks = this._activeAsyncOperations.get(path);\n\n    this._activeAsyncOperations.delete(path); // Run the operation\n    // When in idle mode, we will enter sync mode\n\n\n    let result;\n\n    try {\n      result = this._syncProvider.call(this._providerContext, path);\n    } catch (err) {\n      this._storeResult(path, err, undefined);\n\n      this._enterSyncModeWhenIdle();\n\n      if (callbacks) runCallbacks(callbacks, err, undefined);\n      throw err;\n    }\n\n    this._storeResult(path, undefined, result);\n\n    this._enterSyncModeWhenIdle();\n\n    if (callbacks) runCallbacks(callbacks, undefined, result);\n    return result;\n  }\n\n  purge(what) {\n    if (!what) {\n      if (this._mode !== STORAGE_MODE_IDLE) {\n        this._data.clear();\n\n        for (const level of this._levels) {\n          level.clear();\n        }\n\n        this._enterIdleMode();\n      }\n    } else if (typeof what === \"string\") {\n      for (let [key, data] of this._data) {\n        if (key.startsWith(what)) {\n          this._data.delete(key);\n\n          data.level.delete(key);\n        }\n      }\n\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    } else {\n      for (let [key, data] of this._data) {\n        for (const item of what) {\n          if (key.startsWith(item)) {\n            this._data.delete(key);\n\n            data.level.delete(key);\n            break;\n          }\n        }\n      }\n\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    }\n  }\n\n  purgeParent(what) {\n    if (!what) {\n      this.purge();\n    } else if (typeof what === \"string\") {\n      this.purge(dirname(what));\n    } else {\n      const set = new Set();\n\n      for (const item of what) {\n        set.add(dirname(item));\n      }\n\n      this.purge(set);\n    }\n  }\n\n  _storeResult(path, err, result) {\n    if (this._data.has(path)) return;\n    const level = this._levels[this._currentLevel];\n\n    this._data.set(path, {\n      err,\n      result,\n      level\n    });\n\n    level.add(path);\n  }\n\n  _decayLevel() {\n    const nextLevel = (this._currentLevel + 1) % this._levels.length;\n    const decay = this._levels[nextLevel];\n    this._currentLevel = nextLevel;\n\n    for (let item of decay) {\n      this._data.delete(item);\n    }\n\n    decay.clear();\n\n    if (this._data.size === 0) {\n      this._enterIdleMode();\n    } else {\n      // @ts-ignore _nextDecay is always a number in sync mode\n      this._nextDecay += this._tickInterval;\n    }\n  }\n\n  _runDecays() {\n    while (\n    /** @type {number} */\n    this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE) {\n      this._decayLevel();\n    }\n  }\n\n  _enterAsyncMode() {\n    let timeout = 0;\n\n    switch (this._mode) {\n      case STORAGE_MODE_ASYNC:\n        return;\n\n      case STORAGE_MODE_IDLE:\n        this._nextDecay = Date.now() + this._tickInterval;\n        timeout = this._tickInterval;\n        break;\n\n      case STORAGE_MODE_SYNC:\n        this._runDecays(); // @ts-ignore _runDecays may change the mode\n\n\n        if (this._mode === STORAGE_MODE_IDLE) return;\n        timeout = Math.max(0,\n        /** @type {number} */\n        this._nextDecay - Date.now());\n        break;\n    }\n\n    this._mode = STORAGE_MODE_ASYNC;\n    const ref = setTimeout(() => {\n      this._mode = STORAGE_MODE_SYNC;\n\n      this._runDecays();\n    }, timeout);\n    if (ref.unref) ref.unref();\n    this._timeout = ref;\n  }\n\n  _enterSyncModeWhenIdle() {\n    if (this._mode === STORAGE_MODE_IDLE) {\n      this._mode = STORAGE_MODE_SYNC;\n      this._nextDecay = Date.now() + this._tickInterval;\n    }\n  }\n\n  _enterIdleMode() {\n    this._mode = STORAGE_MODE_IDLE;\n    this._nextDecay = undefined;\n    if (this._timeout) clearTimeout(this._timeout);\n  }\n\n}\n\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n  if (duration > 0) {\n    return new CacheBackend(duration, provider, syncProvider, providerContext);\n  }\n\n  return new OperationMergerBackend(provider, syncProvider, providerContext);\n};\n\nmodule.exports = class CachedInputFileSystem {\n  constructor(fileSystem, duration) {\n    this.fileSystem = fileSystem;\n    this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);\n    const lstat = this._lstatBackend.provide;\n    this.lstat =\n    /** @type {FileSystem[\"lstat\"]} */\n    lstat;\n    const lstatSync = this._lstatBackend.provideSync;\n    this.lstatSync =\n    /** @type {SyncFileSystem[\"lstatSync\"]} */\n    lstatSync;\n    this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);\n    const stat = this._statBackend.provide;\n    this.stat =\n    /** @type {FileSystem[\"stat\"]} */\n    stat;\n    const statSync = this._statBackend.provideSync;\n    this.statSync =\n    /** @type {SyncFileSystem[\"statSync\"]} */\n    statSync;\n    this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);\n    const readdir = this._readdirBackend.provide;\n    this.readdir =\n    /** @type {FileSystem[\"readdir\"]} */\n    readdir;\n    const readdirSync = this._readdirBackend.provideSync;\n    this.readdirSync =\n    /** @type {SyncFileSystem[\"readdirSync\"]} */\n    readdirSync;\n    this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);\n    const readFile = this._readFileBackend.provide;\n    this.readFile =\n    /** @type {FileSystem[\"readFile\"]} */\n    readFile;\n    const readFileSync = this._readFileBackend.provideSync;\n    this.readFileSync =\n    /** @type {SyncFileSystem[\"readFileSync\"]} */\n    readFileSync;\n    this._readJsonBackend = createBackend(duration, this.fileSystem.readJson || this.readFile && ((path, callback) => {\n      // @ts-ignore\n      this.readFile(path, (err, buffer) => {\n        if (err) return callback(err);\n        if (!buffer || buffer.length === 0) return callback(new Error(\"No file content\"));\n        let data;\n\n        try {\n          data = JSON.parse(buffer.toString(\"utf-8\"));\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null, data);\n      });\n    }), this.fileSystem.readJsonSync || this.readFileSync && (path => {\n      const buffer = this.readFileSync(path);\n      const data = JSON.parse(buffer.toString(\"utf-8\"));\n      return data;\n    }), this.fileSystem);\n    const readJson = this._readJsonBackend.provide;\n    this.readJson =\n    /** @type {FileSystem[\"readJson\"]} */\n    readJson;\n    const readJsonSync = this._readJsonBackend.provideSync;\n    this.readJsonSync =\n    /** @type {SyncFileSystem[\"readJsonSync\"]} */\n    readJsonSync;\n    this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);\n    const readlink = this._readlinkBackend.provide;\n    this.readlink =\n    /** @type {FileSystem[\"readlink\"]} */\n    readlink;\n    const readlinkSync = this._readlinkBackend.provideSync;\n    this.readlinkSync =\n    /** @type {SyncFileSystem[\"readlinkSync\"]} */\n    readlinkSync;\n  }\n\n  purge(what) {\n    this._statBackend.purge(what);\n\n    this._lstatBackend.purge(what);\n\n    this._readdirBackend.purgeParent(what);\n\n    this._readFileBackend.purge(what);\n\n    this._readlinkBackend.purge(what);\n\n    this._readJsonBackend.purge(what);\n  }\n\n};","map":{"version":3,"names":["nextTick","require","dirname","path","idx","length","c","charCodeAt","slice","runCallbacks","callbacks","err","result","error","callback","e","OperationMergerBackend","constructor","provider","syncProvider","providerContext","_provider","_syncProvider","_providerContext","_activeAsyncOperations","Map","provide","options","undefined","call","TypeError","get","push","set","delete","provideSync","purge","purgeParent","STORAGE_MODE_IDLE","STORAGE_MODE_SYNC","STORAGE_MODE_ASYNC","CacheBackend","duration","_duration","_data","_levels","i","Set","_currentLevel","_tickInterval","Math","floor","_mode","_timeout","_nextDecay","bind","_enterAsyncMode","cacheEntry","_storeResult","_runDecays","_enterSyncModeWhenIdle","what","clear","level","_enterIdleMode","key","data","startsWith","size","item","add","has","_decayLevel","nextLevel","decay","Date","now","timeout","max","ref","setTimeout","unref","clearTimeout","createBackend","module","exports","CachedInputFileSystem","fileSystem","_lstatBackend","lstat","lstatSync","_statBackend","stat","statSync","_readdirBackend","readdir","readdirSync","_readFileBackend","readFile","readFileSync","_readJsonBackend","readJson","buffer","Error","JSON","parse","toString","readJsonSync","_readlinkBackend","readlink","readlinkSync"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst nextTick = require(\"process\").nextTick;\r\n\r\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\r\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\r\n\r\nconst dirname = path => {\r\n\tlet idx = path.length - 1;\r\n\twhile (idx >= 0) {\r\n\t\tconst c = path.charCodeAt(idx);\r\n\t\t// slash or backslash\r\n\t\tif (c === 47 || c === 92) break;\r\n\t\tidx--;\r\n\t}\r\n\tif (idx < 0) return \"\";\r\n\treturn path.slice(0, idx);\r\n};\r\n\r\nconst runCallbacks = (callbacks, err, result) => {\r\n\tif (callbacks.length === 1) {\r\n\t\tcallbacks[0](err, result);\r\n\t\tcallbacks.length = 0;\r\n\t\treturn;\r\n\t}\r\n\tlet error;\r\n\tfor (const callback of callbacks) {\r\n\t\ttry {\r\n\t\t\tcallback(err, result);\r\n\t\t} catch (e) {\r\n\t\t\tif (!error) error = e;\r\n\t\t}\r\n\t}\r\n\tcallbacks.length = 0;\r\n\tif (error) throw error;\r\n};\r\n\r\nclass OperationMergerBackend {\r\n\t/**\r\n\t * @param {any} provider async method\r\n\t * @param {any} syncProvider sync method\r\n\t * @param {any} providerContext call context for the provider methods\r\n\t */\r\n\tconstructor(provider, syncProvider, providerContext) {\r\n\t\tthis._provider = provider;\r\n\t\tthis._syncProvider = syncProvider;\r\n\t\tthis._providerContext = providerContext;\r\n\t\tthis._activeAsyncOperations = new Map();\r\n\r\n\t\tthis.provide = this._provider\r\n\t\t\t? (path, options, callback) => {\r\n\t\t\t\t\tif (typeof options === \"function\") {\r\n\t\t\t\t\t\tcallback = options;\r\n\t\t\t\t\t\toptions = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (options) {\r\n\t\t\t\t\t\treturn this._provider.call(\r\n\t\t\t\t\t\t\tthis._providerContext,\r\n\t\t\t\t\t\t\tpath,\r\n\t\t\t\t\t\t\toptions,\r\n\t\t\t\t\t\t\tcallback\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof path !== \"string\") {\r\n\t\t\t\t\t\tcallback(new TypeError(\"path must be a string\"));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet callbacks = this._activeAsyncOperations.get(path);\r\n\t\t\t\t\tif (callbacks) {\r\n\t\t\t\t\t\tcallbacks.push(callback);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\r\n\t\t\t\t\tprovider(path, (err, result) => {\r\n\t\t\t\t\t\tthis._activeAsyncOperations.delete(path);\r\n\t\t\t\t\t\trunCallbacks(callbacks, err, result);\r\n\t\t\t\t\t});\r\n\t\t\t  }\r\n\t\t\t: null;\r\n\t\tthis.provideSync = this._syncProvider\r\n\t\t\t? (path, options) => {\r\n\t\t\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\r\n\t\t\t  }\r\n\t\t\t: null;\r\n\t}\r\n\r\n\tpurge() {}\r\n\tpurgeParent() {}\r\n}\r\n\r\n/*\r\n\r\nIDLE:\r\n\tinsert data: goto SYNC\r\n\r\nSYNC:\r\n\tbefore provide: run ticks\r\n\tevent loop tick: goto ASYNC_ACTIVE\r\n\r\nASYNC:\r\n\ttimeout: run tick, goto ASYNC_PASSIVE\r\n\r\nASYNC_PASSIVE:\r\n\tbefore provide: run ticks\r\n\r\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\r\n                                                          ^                             |\r\n                                                          +---------[insert data]-------+\r\n*/\r\n\r\nconst STORAGE_MODE_IDLE = 0;\r\nconst STORAGE_MODE_SYNC = 1;\r\nconst STORAGE_MODE_ASYNC = 2;\r\n\r\nclass CacheBackend {\r\n\t/**\r\n\t * @param {number} duration max cache duration of items\r\n\t * @param {any} provider async method\r\n\t * @param {any} syncProvider sync method\r\n\t * @param {any} providerContext call context for the provider methods\r\n\t */\r\n\tconstructor(duration, provider, syncProvider, providerContext) {\r\n\t\tthis._duration = duration;\r\n\t\tthis._provider = provider;\r\n\t\tthis._syncProvider = syncProvider;\r\n\t\tthis._providerContext = providerContext;\r\n\t\t/** @type {Map<string, (function(Error, any): void)[]>} */\r\n\t\tthis._activeAsyncOperations = new Map();\r\n\t\t/** @type {Map<string, { err: Error, result: any, level: Set<string> }>} */\r\n\t\tthis._data = new Map();\r\n\t\t/** @type {Set<string>[]} */\r\n\t\tthis._levels = [];\r\n\t\tfor (let i = 0; i < 10; i++) this._levels.push(new Set());\r\n\t\tfor (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\r\n\t\tthis._currentLevel = 0;\r\n\t\tthis._tickInterval = Math.floor(duration / this._levels.length);\r\n\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\r\n\t\tthis._mode = STORAGE_MODE_IDLE;\r\n\r\n\t\t/** @type {NodeJS.Timeout | undefined} */\r\n\t\tthis._timeout = undefined;\r\n\t\t/** @type {number | undefined} */\r\n\t\tthis._nextDecay = undefined;\r\n\r\n\t\tthis.provide = provider ? this.provide.bind(this) : null;\r\n\t\tthis.provideSync = syncProvider ? this.provideSync.bind(this) : null;\r\n\t}\r\n\r\n\tprovide(path, options, callback) {\r\n\t\tif (typeof options === \"function\") {\r\n\t\t\tcallback = options;\r\n\t\t\toptions = undefined;\r\n\t\t}\r\n\t\tif (typeof path !== \"string\") {\r\n\t\t\tcallback(new TypeError(\"path must be a string\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (options) {\r\n\t\t\treturn this._provider.call(\r\n\t\t\t\tthis._providerContext,\r\n\t\t\t\tpath,\r\n\t\t\t\toptions,\r\n\t\t\t\tcallback\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// When in sync mode we can move to async mode\r\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\r\n\t\t\tthis._enterAsyncMode();\r\n\t\t}\r\n\r\n\t\t// Check in cache\r\n\t\tlet cacheEntry = this._data.get(path);\r\n\t\tif (cacheEntry !== undefined) {\r\n\t\t\tif (cacheEntry.err) return nextTick(callback, cacheEntry.err);\r\n\t\t\treturn nextTick(callback, null, cacheEntry.result);\r\n\t\t}\r\n\r\n\t\t// Check if there is already the same operation running\r\n\t\tlet callbacks = this._activeAsyncOperations.get(path);\r\n\t\tif (callbacks !== undefined) {\r\n\t\t\tcallbacks.push(callback);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\r\n\r\n\t\t// Run the operation\r\n\t\tthis._provider.call(this._providerContext, path, (err, result) => {\r\n\t\t\tthis._activeAsyncOperations.delete(path);\r\n\t\t\tthis._storeResult(path, err, result);\r\n\r\n\t\t\t// Enter async mode if not yet done\r\n\t\t\tthis._enterAsyncMode();\r\n\r\n\t\t\trunCallbacks(callbacks, err, result);\r\n\t\t});\r\n\t}\r\n\r\n\tprovideSync(path, options) {\r\n\t\tif (typeof path !== \"string\") {\r\n\t\t\tthrow new TypeError(\"path must be a string\");\r\n\t\t}\r\n\t\tif (options) {\r\n\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\r\n\t\t}\r\n\r\n\t\t// In sync mode we may have to decay some cache items\r\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\r\n\t\t\tthis._runDecays();\r\n\t\t}\r\n\r\n\t\t// Check in cache\r\n\t\tlet cacheEntry = this._data.get(path);\r\n\t\tif (cacheEntry !== undefined) {\r\n\t\t\tif (cacheEntry.err) throw cacheEntry.err;\r\n\t\t\treturn cacheEntry.result;\r\n\t\t}\r\n\r\n\t\t// Get all active async operations\r\n\t\t// This sync operation will also complete them\r\n\t\tconst callbacks = this._activeAsyncOperations.get(path);\r\n\t\tthis._activeAsyncOperations.delete(path);\r\n\r\n\t\t// Run the operation\r\n\t\t// When in idle mode, we will enter sync mode\r\n\t\tlet result;\r\n\t\ttry {\r\n\t\t\tresult = this._syncProvider.call(this._providerContext, path);\r\n\t\t} catch (err) {\r\n\t\t\tthis._storeResult(path, err, undefined);\r\n\t\t\tthis._enterSyncModeWhenIdle();\r\n\t\t\tif (callbacks) runCallbacks(callbacks, err, undefined);\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t\tthis._storeResult(path, undefined, result);\r\n\t\tthis._enterSyncModeWhenIdle();\r\n\t\tif (callbacks) runCallbacks(callbacks, undefined, result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpurge(what) {\r\n\t\tif (!what) {\r\n\t\t\tif (this._mode !== STORAGE_MODE_IDLE) {\r\n\t\t\t\tthis._data.clear();\r\n\t\t\t\tfor (const level of this._levels) {\r\n\t\t\t\t\tlevel.clear();\r\n\t\t\t\t}\r\n\t\t\t\tthis._enterIdleMode();\r\n\t\t\t}\r\n\t\t} else if (typeof what === \"string\") {\r\n\t\t\tfor (let [key, data] of this._data) {\r\n\t\t\t\tif (key.startsWith(what)) {\r\n\t\t\t\t\tthis._data.delete(key);\r\n\t\t\t\t\tdata.level.delete(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this._data.size === 0) {\r\n\t\t\t\tthis._enterIdleMode();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let [key, data] of this._data) {\r\n\t\t\t\tfor (const item of what) {\r\n\t\t\t\t\tif (key.startsWith(item)) {\r\n\t\t\t\t\t\tthis._data.delete(key);\r\n\t\t\t\t\t\tdata.level.delete(key);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this._data.size === 0) {\r\n\t\t\t\tthis._enterIdleMode();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpurgeParent(what) {\r\n\t\tif (!what) {\r\n\t\t\tthis.purge();\r\n\t\t} else if (typeof what === \"string\") {\r\n\t\t\tthis.purge(dirname(what));\r\n\t\t} else {\r\n\t\t\tconst set = new Set();\r\n\t\t\tfor (const item of what) {\r\n\t\t\t\tset.add(dirname(item));\r\n\t\t\t}\r\n\t\t\tthis.purge(set);\r\n\t\t}\r\n\t}\r\n\r\n\t_storeResult(path, err, result) {\r\n\t\tif (this._data.has(path)) return;\r\n\t\tconst level = this._levels[this._currentLevel];\r\n\t\tthis._data.set(path, { err, result, level });\r\n\t\tlevel.add(path);\r\n\t}\r\n\r\n\t_decayLevel() {\r\n\t\tconst nextLevel = (this._currentLevel + 1) % this._levels.length;\r\n\t\tconst decay = this._levels[nextLevel];\r\n\t\tthis._currentLevel = nextLevel;\r\n\t\tfor (let item of decay) {\r\n\t\t\tthis._data.delete(item);\r\n\t\t}\r\n\t\tdecay.clear();\r\n\t\tif (this._data.size === 0) {\r\n\t\t\tthis._enterIdleMode();\r\n\t\t} else {\r\n\t\t\t// @ts-ignore _nextDecay is always a number in sync mode\r\n\t\t\tthis._nextDecay += this._tickInterval;\r\n\t\t}\r\n\t}\r\n\r\n\t_runDecays() {\r\n\t\twhile (\r\n\t\t\t/** @type {number} */ (this._nextDecay) <= Date.now() &&\r\n\t\t\tthis._mode !== STORAGE_MODE_IDLE\r\n\t\t) {\r\n\t\t\tthis._decayLevel();\r\n\t\t}\r\n\t}\r\n\r\n\t_enterAsyncMode() {\r\n\t\tlet timeout = 0;\r\n\t\tswitch (this._mode) {\r\n\t\t\tcase STORAGE_MODE_ASYNC:\r\n\t\t\t\treturn;\r\n\t\t\tcase STORAGE_MODE_IDLE:\r\n\t\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\r\n\t\t\t\ttimeout = this._tickInterval;\r\n\t\t\t\tbreak;\r\n\t\t\tcase STORAGE_MODE_SYNC:\r\n\t\t\t\tthis._runDecays();\r\n\t\t\t\t// @ts-ignore _runDecays may change the mode\r\n\t\t\t\tif (this._mode === STORAGE_MODE_IDLE) return;\r\n\t\t\t\ttimeout = Math.max(\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t/** @type {number} */ (this._nextDecay) - Date.now()\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tthis._mode = STORAGE_MODE_ASYNC;\r\n\t\tconst ref = setTimeout(() => {\r\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\r\n\t\t\tthis._runDecays();\r\n\t\t}, timeout);\r\n\t\tif (ref.unref) ref.unref();\r\n\t\tthis._timeout = ref;\r\n\t}\r\n\r\n\t_enterSyncModeWhenIdle() {\r\n\t\tif (this._mode === STORAGE_MODE_IDLE) {\r\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\r\n\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\r\n\t\t}\r\n\t}\r\n\r\n\t_enterIdleMode() {\r\n\t\tthis._mode = STORAGE_MODE_IDLE;\r\n\t\tthis._nextDecay = undefined;\r\n\t\tif (this._timeout) clearTimeout(this._timeout);\r\n\t}\r\n}\r\n\r\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\r\n\tif (duration > 0) {\r\n\t\treturn new CacheBackend(duration, provider, syncProvider, providerContext);\r\n\t}\r\n\treturn new OperationMergerBackend(provider, syncProvider, providerContext);\r\n};\r\n\r\nmodule.exports = class CachedInputFileSystem {\r\n\tconstructor(fileSystem, duration) {\r\n\t\tthis.fileSystem = fileSystem;\r\n\r\n\t\tthis._lstatBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.lstat,\r\n\t\t\tthis.fileSystem.lstatSync,\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst lstat = this._lstatBackend.provide;\r\n\t\tthis.lstat = /** @type {FileSystem[\"lstat\"]} */ (lstat);\r\n\t\tconst lstatSync = this._lstatBackend.provideSync;\r\n\t\tthis.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */ (lstatSync);\r\n\r\n\t\tthis._statBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.stat,\r\n\t\t\tthis.fileSystem.statSync,\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst stat = this._statBackend.provide;\r\n\t\tthis.stat = /** @type {FileSystem[\"stat\"]} */ (stat);\r\n\t\tconst statSync = this._statBackend.provideSync;\r\n\t\tthis.statSync = /** @type {SyncFileSystem[\"statSync\"]} */ (statSync);\r\n\r\n\t\tthis._readdirBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.readdir,\r\n\t\t\tthis.fileSystem.readdirSync,\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst readdir = this._readdirBackend.provide;\r\n\t\tthis.readdir = /** @type {FileSystem[\"readdir\"]} */ (readdir);\r\n\t\tconst readdirSync = this._readdirBackend.provideSync;\r\n\t\tthis.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */ (readdirSync);\r\n\r\n\t\tthis._readFileBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.readFile,\r\n\t\t\tthis.fileSystem.readFileSync,\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst readFile = this._readFileBackend.provide;\r\n\t\tthis.readFile = /** @type {FileSystem[\"readFile\"]} */ (readFile);\r\n\t\tconst readFileSync = this._readFileBackend.provideSync;\r\n\t\tthis.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */ (readFileSync);\r\n\r\n\t\tthis._readJsonBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.readJson ||\r\n\t\t\t\t(this.readFile &&\r\n\t\t\t\t\t((path, callback) => {\r\n\t\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\t\tthis.readFile(path, (err, buffer) => {\r\n\t\t\t\t\t\t\tif (err) return callback(err);\r\n\t\t\t\t\t\t\tif (!buffer || buffer.length === 0)\r\n\t\t\t\t\t\t\t\treturn callback(new Error(\"No file content\"));\r\n\t\t\t\t\t\t\tlet data;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tdata = JSON.parse(buffer.toString(\"utf-8\"));\r\n\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\treturn callback(e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcallback(null, data);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})),\r\n\t\t\tthis.fileSystem.readJsonSync ||\r\n\t\t\t\t(this.readFileSync &&\r\n\t\t\t\t\t(path => {\r\n\t\t\t\t\t\tconst buffer = this.readFileSync(path);\r\n\t\t\t\t\t\tconst data = JSON.parse(buffer.toString(\"utf-8\"));\r\n\t\t\t\t\t\treturn data;\r\n\t\t\t\t\t})),\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst readJson = this._readJsonBackend.provide;\r\n\t\tthis.readJson = /** @type {FileSystem[\"readJson\"]} */ (readJson);\r\n\t\tconst readJsonSync = this._readJsonBackend.provideSync;\r\n\t\tthis.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */ (readJsonSync);\r\n\r\n\t\tthis._readlinkBackend = createBackend(\r\n\t\t\tduration,\r\n\t\t\tthis.fileSystem.readlink,\r\n\t\t\tthis.fileSystem.readlinkSync,\r\n\t\t\tthis.fileSystem\r\n\t\t);\r\n\t\tconst readlink = this._readlinkBackend.provide;\r\n\t\tthis.readlink = /** @type {FileSystem[\"readlink\"]} */ (readlink);\r\n\t\tconst readlinkSync = this._readlinkBackend.provideSync;\r\n\t\tthis.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */ (readlinkSync);\r\n\t}\r\n\r\n\tpurge(what) {\r\n\t\tthis._statBackend.purge(what);\r\n\t\tthis._lstatBackend.purge(what);\r\n\t\tthis._readdirBackend.purgeParent(what);\r\n\t\tthis._readFileBackend.purge(what);\r\n\t\tthis._readlinkBackend.purge(what);\r\n\t\tthis._readJsonBackend.purge(what);\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}