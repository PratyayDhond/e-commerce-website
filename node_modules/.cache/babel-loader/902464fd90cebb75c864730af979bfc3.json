{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\n\nconst getSource = require(\"./getSource\");\n\nconst readMappings = require(\"./readMappings\");\n\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {\n  const lines = splitIntoLines(source);\n\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  let currentGeneratedLine = 1;\n  let currentGeneratedColumn = 0;\n  let mappingActive = false;\n  let activeMappingSourceIndex = -1;\n  let activeMappingOriginalLine = -1;\n  let activeMappingOriginalColumn = -1;\n  let activeMappingNameIndex = -1;\n\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (mappingActive && currentGeneratedLine <= lines.length) {\n      let chunk;\n      const mappingLine = currentGeneratedLine;\n      const mappingColumn = currentGeneratedColumn;\n      const line = lines[currentGeneratedLine - 1];\n\n      if (generatedLine !== currentGeneratedLine) {\n        chunk = line.slice(currentGeneratedColumn);\n        currentGeneratedLine++;\n        currentGeneratedColumn = 0;\n      } else {\n        chunk = line.slice(currentGeneratedColumn, generatedColumn);\n        currentGeneratedColumn = generatedColumn;\n      }\n\n      if (chunk) {\n        onChunk(chunk, mappingLine, mappingColumn, activeMappingSourceIndex, activeMappingOriginalLine, activeMappingOriginalColumn, activeMappingNameIndex);\n      }\n\n      mappingActive = false;\n    }\n\n    if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n      currentGeneratedColumn = 0;\n    }\n\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n    }\n\n    if (generatedColumn > currentGeneratedColumn) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn, generatedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n\n      currentGeneratedColumn = generatedColumn;\n    }\n\n    if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {\n      mappingActive = true;\n      activeMappingSourceIndex = sourceIndex;\n      activeMappingOriginalLine = originalLine;\n      activeMappingOriginalColumn = originalColumn;\n      activeMappingNameIndex = nameIndex;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  onMapping(finalLine, finalColumn, -1, -1, -1, -1);\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\n\nconst streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {\n  const lines = splitIntoLines(source);\n\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  let currentGeneratedLine = 1;\n\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {\n      return;\n    }\n\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n    }\n\n    if (generatedLine <= lines.length) {\n      onChunk(lines[generatedLine - 1], generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine++;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n\n  for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n    onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\n\nconst streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  } = result;\n  if (finalLine === 1 && finalColumn === 0) return result;\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n\n  let mappingActiveLine = 0;\n\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {\n      return;\n    }\n\n    if (sourceIndex >= 0) {\n      onChunk(undefined, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n      mappingActiveLine = generatedLine;\n    } else if (mappingActiveLine === generatedLine) {\n      onChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n      mappingActiveLine = 0;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  return result;\n};\n\nconst streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine,\n    generatedColumn\n  } = result;\n\n  if (generatedLine === 1 && generatedColumn === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n  let currentGeneratedLine = 1;\n\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine && generatedLine <= finalLine) {\n      onChunk(undefined, generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine = generatedLine + 1;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  return result;\n};\n\nmodule.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {\n  if (columns) {\n    return finalSource ? streamChunksOfSourceMapFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapFull(source, sourceMap, onChunk, onSource, onName);\n  } else {\n    return finalSource ? streamChunksOfSourceMapLinesFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapLinesFull(source, sourceMap, onChunk, onSource, onName);\n  }\n};","map":{"version":3,"names":["getGeneratedSourceInfo","require","getSource","readMappings","splitIntoLines","streamChunksOfSourceMapFull","source","sourceMap","onChunk","onSource","onName","lines","length","generatedLine","generatedColumn","sources","sourcesContent","names","mappings","i","undefined","lastLine","lastNewLine","endsWith","finalLine","finalColumn","currentGeneratedLine","currentGeneratedColumn","mappingActive","activeMappingSourceIndex","activeMappingOriginalLine","activeMappingOriginalColumn","activeMappingNameIndex","onMapping","sourceIndex","originalLine","originalColumn","nameIndex","chunk","mappingLine","mappingColumn","line","slice","streamChunksOfSourceMapLinesFull","_onName","_generatedColumn","_nameIndex","streamChunksOfSourceMapFinal","result","mappingActiveLine","streamChunksOfSourceMapLinesFinal","module","exports","finalSource","columns"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\r\nconst getSource = require(\"./getSource\");\r\nconst readMappings = require(\"./readMappings\");\r\nconst splitIntoLines = require(\"./splitIntoLines\");\r\n\r\nconst streamChunksOfSourceMapFull = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName\r\n) => {\r\n\tconst lines = splitIntoLines(source);\r\n\tif (lines.length === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\tif (names) {\r\n\t\tfor (let i = 0; i < names.length; i++) {\r\n\t\t\tonName(i, names[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tconst lastLine = lines[lines.length - 1];\r\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\r\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\r\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\tlet currentGeneratedColumn = 0;\r\n\r\n\tlet mappingActive = false;\r\n\tlet activeMappingSourceIndex = -1;\r\n\tlet activeMappingOriginalLine = -1;\r\n\tlet activeMappingOriginalColumn = -1;\r\n\tlet activeMappingNameIndex = -1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\tgeneratedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\tnameIndex\r\n\t) => {\r\n\t\tif (mappingActive && currentGeneratedLine <= lines.length) {\r\n\t\t\tlet chunk;\r\n\t\t\tconst mappingLine = currentGeneratedLine;\r\n\t\t\tconst mappingColumn = currentGeneratedColumn;\r\n\t\t\tconst line = lines[currentGeneratedLine - 1];\r\n\t\t\tif (generatedLine !== currentGeneratedLine) {\r\n\t\t\t\tchunk = line.slice(currentGeneratedColumn);\r\n\t\t\t\tcurrentGeneratedLine++;\r\n\t\t\t\tcurrentGeneratedColumn = 0;\r\n\t\t\t} else {\r\n\t\t\t\tchunk = line.slice(currentGeneratedColumn, generatedColumn);\r\n\t\t\t\tcurrentGeneratedColumn = generatedColumn;\r\n\t\t\t}\r\n\t\t\tif (chunk) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tmappingLine,\r\n\t\t\t\t\tmappingColumn,\r\n\t\t\t\t\tactiveMappingSourceIndex,\r\n\t\t\t\t\tactiveMappingOriginalLine,\r\n\t\t\t\t\tactiveMappingOriginalColumn,\r\n\t\t\t\t\tactiveMappingNameIndex\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tmappingActive = false;\r\n\t\t}\r\n\t\tif (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\r\n\t\t\t\t\tcurrentGeneratedColumn\r\n\t\t\t\t);\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t\tcurrentGeneratedColumn = 0;\r\n\t\t}\r\n\t\twhile (generatedLine > currentGeneratedLine) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t\tif (generatedColumn > currentGeneratedColumn) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\tgeneratedColumn\r\n\t\t\t\t);\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedColumn = generatedColumn;\r\n\t\t}\r\n\t\tif (\r\n\t\t\tsourceIndex >= 0 &&\r\n\t\t\t(generatedLine < finalLine ||\r\n\t\t\t\t(generatedLine === finalLine && generatedColumn < finalColumn))\r\n\t\t) {\r\n\t\t\tmappingActive = true;\r\n\t\t\tactiveMappingSourceIndex = sourceIndex;\r\n\t\t\tactiveMappingOriginalLine = originalLine;\r\n\t\t\tactiveMappingOriginalColumn = originalColumn;\r\n\t\t\tactiveMappingNameIndex = nameIndex;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\tonMapping(finalLine, finalColumn, -1, -1, -1, -1);\r\n\treturn {\r\n\t\tgeneratedLine: finalLine,\r\n\t\tgeneratedColumn: finalColumn\r\n\t};\r\n};\r\n\r\nconst streamChunksOfSourceMapLinesFull = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\t_onName\r\n) => {\r\n\tconst lines = splitIntoLines(source);\r\n\tif (lines.length === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\tconst { sources, sourcesContent, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\t_generatedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\t_nameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tsourceIndex < 0 ||\r\n\t\t\tgeneratedLine < currentGeneratedLine ||\r\n\t\t\tgeneratedLine > lines.length\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twhile (generatedLine > currentGeneratedLine) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t\tif (generatedLine <= lines.length) {\r\n\t\t\tonChunk(\r\n\t\t\t\tlines[generatedLine - 1],\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\t0,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\t-1\r\n\t\t\t);\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\tfor (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\r\n\t\tonChunk(\r\n\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\tcurrentGeneratedLine,\r\n\t\t\t0,\r\n\t\t\t-1,\r\n\t\t\t-1,\r\n\t\t\t-1,\r\n\t\t\t-1\r\n\t\t);\r\n\t}\r\n\r\n\tconst lastLine = lines[lines.length - 1];\r\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\r\n\r\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\r\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\r\n\r\n\treturn {\r\n\t\tgeneratedLine: finalLine,\r\n\t\tgeneratedColumn: finalColumn\r\n\t};\r\n};\r\n\r\nconst streamChunksOfSourceMapFinal = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName\r\n) => {\r\n\tconst result = getGeneratedSourceInfo(source);\r\n\tconst { generatedLine: finalLine, generatedColumn: finalColumn } = result;\r\n\r\n\tif (finalLine === 1 && finalColumn === 0) return result;\r\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\tif (names) {\r\n\t\tfor (let i = 0; i < names.length; i++) {\r\n\t\t\tonName(i, names[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tlet mappingActiveLine = 0;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\tgeneratedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\tnameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tgeneratedLine >= finalLine &&\r\n\t\t\t(generatedColumn >= finalColumn || generatedLine > finalLine)\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (sourceIndex >= 0) {\r\n\t\t\tonChunk(\r\n\t\t\t\tundefined,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\tgeneratedColumn,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\tnameIndex\r\n\t\t\t);\r\n\t\t\tmappingActiveLine = generatedLine;\r\n\t\t} else if (mappingActiveLine === generatedLine) {\r\n\t\t\tonChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\r\n\t\t\tmappingActiveLine = 0;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\treturn result;\r\n};\r\n\r\nconst streamChunksOfSourceMapLinesFinal = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\t_onName\r\n) => {\r\n\tconst result = getGeneratedSourceInfo(source);\r\n\tconst { generatedLine, generatedColumn } = result;\r\n\tif (generatedLine === 1 && generatedColumn === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\r\n\tconst { sources, sourcesContent, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\r\n\tconst finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\t_generatedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\t_nameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tsourceIndex >= 0 &&\r\n\t\t\tcurrentGeneratedLine <= generatedLine &&\r\n\t\t\tgeneratedLine <= finalLine\r\n\t\t) {\r\n\t\t\tonChunk(\r\n\t\t\t\tundefined,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\t0,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\t-1\r\n\t\t\t);\r\n\t\t\tcurrentGeneratedLine = generatedLine + 1;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\treturn result;\r\n};\r\n\r\nmodule.exports = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName,\r\n\tfinalSource,\r\n\tcolumns\r\n) => {\r\n\tif (columns) {\r\n\t\treturn finalSource\r\n\t\t\t? streamChunksOfSourceMapFinal(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  )\r\n\t\t\t: streamChunksOfSourceMapFull(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  );\r\n\t} else {\r\n\t\treturn finalSource\r\n\t\t\t? streamChunksOfSourceMapLinesFinal(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  )\r\n\t\t\t: streamChunksOfSourceMapLinesFull(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  );\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}