{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\r\n * leb: LEB128 utilities.\r\n */\n\n/*\r\n * Modules used\r\n */\n\"use strict\";\n\nimport \"core-js/modules/es.error.cause.js\";\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\r\n * Module variables\r\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\r\n * The maximum possible 64-bit signed int that is representable as a\r\n * JavaScript number.\r\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\r\n * The maximum possible 64-bit unsigned int that is representable as a\r\n * JavaScript number.\r\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\r\n * Helper functions\r\n */\n\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as a signed value. The buffer is\r\n * taken to represent a signed number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order non-sign-matching bit, plus two. For example:\r\n *\r\n *   11111011 01110101\r\n *   high          low\r\n *\r\n * The sign bit here is 1 (that is, it's a negative number). The highest\r\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\r\n * bit is bit #0). So, we have to encode at least 12 bits total.\r\n *\r\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\r\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as an unsigned value. The buffer is\r\n * taken to represent an unsigned number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order 1 bit, plus one. For example:\r\n *\r\n *   00011000 01010011\r\n *   high          low\r\n *\r\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\r\n * is bit #0). So, we have to encode at least 13 bits total.\r\n *\r\n * As a special degenerate case, the number 0 requires 1 bit.\r\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\r\n * Common encoder for both signed and unsigned ints. This takes a\r\n * bigint-ish buffer, returning an LEB128-encoded buffer.\r\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\r\n * Gets the byte-length of the value encoded in the given buffer at\r\n * the given index.\r\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\r\n * Common decoder for both signed and unsigned ints. This takes an\r\n * LEB128-encoded buffer, returning a bigint-ish buffer.\r\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\r\n * Exported bindings\r\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};","map":{"version":3,"names":["Long","bits","bufs","MIN_INT32","MAX_INT32","MAX_UINT32","signedBitCount","buffer","highOrder","getSign","unsignedBitCount","result","encodeBufferCommon","signed","signBit","bitCount","byteCount","Math","ceil","alloc","i","payload","extract","encodedLength","encodedBuffer","index","length","decodeBufferCommon","undefined","bitLength","byteLength","outIndex","inject","signByte","lastByte","endBit","shift","resize","value","nextIndex","encodeIntBuffer","decodeIntBuffer","encodeInt32","num","buf","writeInt32LE","free","decodeInt32","parsed","readInt","Error","encodeInt64","writeInt64","decodeInt64","fromBytesLE","lossy","encodeUIntBuffer","decodeUIntBuffer","encodeUInt32","writeUInt32LE","decodeUInt32","readUInt","encodeUInt64","writeUInt64","decodeUInt64"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/@webassemblyjs/leb128/esm/leb.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\r\n\r\n/*\r\n * leb: LEB128 utilities.\r\n */\r\n\r\n/*\r\n * Modules used\r\n */\r\n\"use strict\";\r\n\r\nimport Long from \"@xtuc/long\";\r\nimport * as bits from \"./bits\";\r\nimport * as bufs from \"./bufs\";\r\n/*\r\n * Module variables\r\n */\r\n\r\n/** The minimum possible 32-bit signed int. */\r\n\r\nvar MIN_INT32 = -0x80000000;\r\n/** The maximum possible 32-bit signed int. */\r\n\r\nvar MAX_INT32 = 0x7fffffff;\r\n/** The maximum possible 32-bit unsigned int. */\r\n\r\nvar MAX_UINT32 = 0xffffffff;\r\n/** The minimum possible 64-bit signed int. */\r\n// const MIN_INT64 = -0x8000000000000000;\r\n\r\n/**\r\n * The maximum possible 64-bit signed int that is representable as a\r\n * JavaScript number.\r\n */\r\n// const MAX_INT64 = 0x7ffffffffffffc00;\r\n\r\n/**\r\n * The maximum possible 64-bit unsigned int that is representable as a\r\n * JavaScript number.\r\n */\r\n// const MAX_UINT64 = 0xfffffffffffff800;\r\n\r\n/*\r\n * Helper functions\r\n */\r\n\r\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as a signed value. The buffer is\r\n * taken to represent a signed number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order non-sign-matching bit, plus two. For example:\r\n *\r\n *   11111011 01110101\r\n *   high          low\r\n *\r\n * The sign bit here is 1 (that is, it's a negative number). The highest\r\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\r\n * bit is bit #0). So, we have to encode at least 12 bits total.\r\n *\r\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\r\n */\r\n\r\nfunction signedBitCount(buffer) {\r\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\r\n}\r\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as an unsigned value. The buffer is\r\n * taken to represent an unsigned number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order 1 bit, plus one. For example:\r\n *\r\n *   00011000 01010011\r\n *   high          low\r\n *\r\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\r\n * is bit #0). So, we have to encode at least 13 bits total.\r\n *\r\n * As a special degenerate case, the number 0 requires 1 bit.\r\n */\r\n\r\n\r\nfunction unsignedBitCount(buffer) {\r\n  var result = bits.highOrder(1, buffer) + 1;\r\n  return result ? result : 1;\r\n}\r\n/**\r\n * Common encoder for both signed and unsigned ints. This takes a\r\n * bigint-ish buffer, returning an LEB128-encoded buffer.\r\n */\r\n\r\n\r\nfunction encodeBufferCommon(buffer, signed) {\r\n  var signBit;\r\n  var bitCount;\r\n\r\n  if (signed) {\r\n    signBit = bits.getSign(buffer);\r\n    bitCount = signedBitCount(buffer);\r\n  } else {\r\n    signBit = 0;\r\n    bitCount = unsignedBitCount(buffer);\r\n  }\r\n\r\n  var byteCount = Math.ceil(bitCount / 7);\r\n  var result = bufs.alloc(byteCount);\r\n\r\n  for (var i = 0; i < byteCount; i++) {\r\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\r\n    result[i] = payload | 0x80;\r\n  } // Mask off the top bit of the last byte, to indicate the end of the\r\n  // encoding.\r\n\r\n\r\n  result[byteCount - 1] &= 0x7f;\r\n  return result;\r\n}\r\n/**\r\n * Gets the byte-length of the value encoded in the given buffer at\r\n * the given index.\r\n */\r\n\r\n\r\nfunction encodedLength(encodedBuffer, index) {\r\n  var result = 0;\r\n\r\n  while (encodedBuffer[index + result] >= 0x80) {\r\n    result++;\r\n  }\r\n\r\n  result++; // to account for the last byte\r\n\r\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\r\n    // throw new Error(\"integer representation too long\");\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n * Common decoder for both signed and unsigned ints. This takes an\r\n * LEB128-encoded buffer, returning a bigint-ish buffer.\r\n */\r\n\r\n\r\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\r\n  index = index === undefined ? 0 : index;\r\n  var length = encodedLength(encodedBuffer, index);\r\n  var bitLength = length * 7;\r\n  var byteLength = Math.ceil(bitLength / 8);\r\n  var result = bufs.alloc(byteLength);\r\n  var outIndex = 0;\r\n\r\n  while (length > 0) {\r\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\r\n    outIndex += 7;\r\n    index++;\r\n    length--;\r\n  }\r\n\r\n  var signBit;\r\n  var signByte;\r\n\r\n  if (signed) {\r\n    // Sign-extend the last byte.\r\n    var lastByte = result[byteLength - 1];\r\n    var endBit = outIndex % 8;\r\n\r\n    if (endBit !== 0) {\r\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\r\n\r\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\r\n    }\r\n\r\n    signBit = lastByte >> 7;\r\n    signByte = signBit * 0xff;\r\n  } else {\r\n    signBit = 0;\r\n    signByte = 0;\r\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\r\n  // bits (because the value would be the same if they were removed).\r\n\r\n\r\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\r\n    byteLength--;\r\n  }\r\n\r\n  result = bufs.resize(result, byteLength);\r\n  return {\r\n    value: result,\r\n    nextIndex: index\r\n  };\r\n}\r\n/*\r\n * Exported bindings\r\n */\r\n\r\n\r\nfunction encodeIntBuffer(buffer) {\r\n  return encodeBufferCommon(buffer, true);\r\n}\r\n\r\nfunction decodeIntBuffer(encodedBuffer, index) {\r\n  return decodeBufferCommon(encodedBuffer, index, true);\r\n}\r\n\r\nfunction encodeInt32(num) {\r\n  var buf = bufs.alloc(4);\r\n  buf.writeInt32LE(num, 0);\r\n  var result = encodeIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeInt32(encodedBuffer, index) {\r\n  var result = decodeIntBuffer(encodedBuffer, index);\r\n  var parsed = bufs.readInt(result.value);\r\n  var value = parsed.value;\r\n  bufs.free(result.value);\r\n\r\n  if (value < MIN_INT32 || value > MAX_INT32) {\r\n    throw new Error(\"integer too large\");\r\n  }\r\n\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex\r\n  };\r\n}\r\n\r\nfunction encodeInt64(num) {\r\n  var buf = bufs.alloc(8);\r\n  bufs.writeInt64(num, buf);\r\n  var result = encodeIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeInt64(encodedBuffer, index) {\r\n  var result = decodeIntBuffer(encodedBuffer, index);\r\n  var value = Long.fromBytesLE(result.value, false);\r\n  bufs.free(result.value);\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex,\r\n    lossy: false\r\n  };\r\n}\r\n\r\nfunction encodeUIntBuffer(buffer) {\r\n  return encodeBufferCommon(buffer, false);\r\n}\r\n\r\nfunction decodeUIntBuffer(encodedBuffer, index) {\r\n  return decodeBufferCommon(encodedBuffer, index, false);\r\n}\r\n\r\nfunction encodeUInt32(num) {\r\n  var buf = bufs.alloc(4);\r\n  buf.writeUInt32LE(num, 0);\r\n  var result = encodeUIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeUInt32(encodedBuffer, index) {\r\n  var result = decodeUIntBuffer(encodedBuffer, index);\r\n  var parsed = bufs.readUInt(result.value);\r\n  var value = parsed.value;\r\n  bufs.free(result.value);\r\n\r\n  if (value > MAX_UINT32) {\r\n    throw new Error(\"integer too large\");\r\n  }\r\n\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex\r\n  };\r\n}\r\n\r\nfunction encodeUInt64(num) {\r\n  var buf = bufs.alloc(8);\r\n  bufs.writeUInt64(num, buf);\r\n  var result = encodeUIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeUInt64(encodedBuffer, index) {\r\n  var result = decodeUIntBuffer(encodedBuffer, index);\r\n  var value = Long.fromBytesLE(result.value, true);\r\n  bufs.free(result.value);\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex,\r\n    lossy: false\r\n  };\r\n}\r\n\r\nexport default {\r\n  decodeInt32: decodeInt32,\r\n  decodeInt64: decodeInt64,\r\n  decodeIntBuffer: decodeIntBuffer,\r\n  decodeUInt32: decodeUInt32,\r\n  decodeUInt64: decodeUInt64,\r\n  decodeUIntBuffer: decodeUIntBuffer,\r\n  encodeInt32: encodeInt32,\r\n  encodeInt64: encodeInt64,\r\n  encodeIntBuffer: encodeIntBuffer,\r\n  encodeUInt32: encodeUInt32,\r\n  encodeUInt64: encodeUInt64,\r\n  encodeUIntBuffer: encodeUIntBuffer\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}