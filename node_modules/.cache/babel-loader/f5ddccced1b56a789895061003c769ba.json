{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst streamChunks = require(\"./helpers/streamChunks\");\n\nconst Source = require(\"./Source\");\n\nconst splitIntoLines = require(\"./helpers/splitIntoLines\"); // since v8 7.0, Array.prototype.sort is stable\n\n\nconst hasStableSort = typeof process === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8); // This is larger than max string length\n\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n  constructor(start, end, content, name) {\n    this.start = start;\n    this.end = end;\n    this.content = content;\n    this.name = name;\n\n    if (!hasStableSort) {\n      this.index = -1;\n    }\n  }\n\n}\n\nclass ReplaceSource extends Source {\n  constructor(source, name) {\n    super();\n    this._source = source;\n    this._name = name;\n    /** @type {Replacement[]} */\n\n    this._replacements = [];\n    this._isSorted = true;\n  }\n\n  getName() {\n    return this._name;\n  }\n\n  getReplacements() {\n    this._sortReplacements();\n\n    return this._replacements;\n  }\n\n  replace(start, end, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n\n    this._replacements.push(new Replacement(start, end, newValue, name));\n\n    this._isSorted = false;\n  }\n\n  insert(pos, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n\n    this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\n    this._isSorted = false;\n  }\n\n  source() {\n    if (this._replacements.length === 0) {\n      return this._source.source();\n    }\n\n    let current = this._source.source();\n\n    let pos = 0;\n    const result = [];\n\n    this._sortReplacements();\n\n    for (const replacement of this._replacements) {\n      const start = Math.floor(replacement.start);\n      const end = Math.floor(replacement.end + 1);\n\n      if (pos < start) {\n        const offset = start - pos;\n        result.push(current.slice(0, offset));\n        current = current.slice(offset);\n        pos = start;\n      }\n\n      result.push(replacement.content);\n\n      if (pos < end) {\n        const offset = end - pos;\n        current = current.slice(offset);\n        pos = end;\n      }\n    }\n\n    result.push(current);\n    return result.join(\"\");\n  }\n\n  map(options) {\n    if (this._replacements.length === 0) {\n      return this._source.map(options);\n    }\n\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    if (this._replacements.length === 0) {\n      return this._source.sourceAndMap(options);\n    }\n\n    return getSourceAndMap(this, options);\n  }\n\n  original() {\n    return this._source;\n  }\n\n  _sortReplacements() {\n    if (this._isSorted) return;\n\n    if (hasStableSort) {\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return 0;\n      });\n    } else {\n      this._replacements.forEach((repl, i) => repl.index = i);\n\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return a.index - b.index;\n      });\n    }\n\n    this._isSorted = true;\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    this._sortReplacements();\n\n    const repls = this._replacements;\n    let pos = 0;\n    let i = 0;\n    let replacmentEnd = -1;\n    let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n    let generatedLineOffset = 0;\n    let generatedColumnOffset = 0;\n    let generatedColumnOffsetLine = 0;\n    const sourceContents = [];\n    const nameMapping = new Map();\n    const nameIndexMapping = [];\n\n    const checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n      let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n      if (content === undefined) return false;\n\n      if (typeof content === \"string\") {\n        content = splitIntoLines(content);\n        sourceContents[sourceIndex] = content;\n      }\n\n      const contentLine = line <= content.length ? content[line - 1] : null;\n      if (contentLine === null) return false;\n      return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n    };\n\n    let {\n      generatedLine,\n      generatedColumn\n    } = streamChunks(this._source, Object.assign({}, options, {\n      finalSource: false\n    }), (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n      let chunkPos = 0;\n      let endPos = pos + chunk.length; // Skip over when it has been replaced\n\n      if (replacmentEnd > pos) {\n        // Skip over the whole chunk\n        if (replacmentEnd >= endPos) {\n          const line = generatedLine + generatedLineOffset;\n\n          if (chunk.endsWith(\"\\n\")) {\n            generatedLineOffset--;\n\n            if (generatedColumnOffsetLine === line) {\n              // undo exiting corrections form the current line\n              generatedColumnOffset += generatedColumn;\n            }\n          } else if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset -= chunk.length;\n          } else {\n            generatedColumnOffset = -chunk.length;\n            generatedColumnOffsetLine = line;\n          }\n\n          pos = endPos;\n          return;\n        } // Partially skip over chunk\n\n\n        chunkPos = replacmentEnd - pos;\n\n        if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n          originalColumn += chunkPos;\n        }\n\n        pos += chunkPos;\n        const line = generatedLine + generatedLineOffset;\n\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset -= chunkPos;\n        } else {\n          generatedColumnOffset = -chunkPos;\n          generatedColumnOffsetLine = line;\n        }\n\n        generatedColumn += chunkPos;\n      } // Is a replacement in the chunk?\n\n\n      if (nextReplacement < endPos) {\n        do {\n          let line = generatedLine + generatedLineOffset;\n\n          if (nextReplacement > pos) {\n            // Emit chunk until replacement\n            const offset = nextReplacement - pos;\n            const chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n            onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n            generatedColumn += offset;\n            chunkPos += offset;\n            pos = nextReplacement;\n\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n              originalColumn += chunkSlice.length;\n            }\n          } // Insert replacement content splitted into chunks by lines\n\n\n          const {\n            content,\n            name\n          } = repls[i];\n          let matches = splitIntoLines(content);\n          let replacementNameIndex = nameIndex;\n\n          if (sourceIndex >= 0 && name) {\n            let globalIndex = nameMapping.get(name);\n\n            if (globalIndex === undefined) {\n              globalIndex = nameMapping.size;\n              nameMapping.set(name, globalIndex);\n              onName(globalIndex, name);\n            }\n\n            replacementNameIndex = globalIndex;\n          }\n\n          for (let m = 0; m < matches.length; m++) {\n            const contentLine = matches[m];\n            onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex); // Only the first chunk has name assigned\n\n            replacementNameIndex = -1;\n\n            if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n              if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset += contentLine.length;\n              } else {\n                generatedColumnOffset = contentLine.length;\n                generatedColumnOffsetLine = line;\n              }\n            } else {\n              generatedLineOffset++;\n              line++;\n              generatedColumnOffset = -generatedColumn;\n              generatedColumnOffsetLine = line;\n            }\n          } // Remove replaced content by settings this variable\n\n\n          replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1)); // Move to next replacment\n\n          i++;\n          nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION; // Skip over when it has been replaced\n\n          const offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\n          if (offset > 0) {\n            // Skip over whole chunk\n            if (replacmentEnd >= endPos) {\n              let line = generatedLine + generatedLineOffset;\n\n              if (chunk.endsWith(\"\\n\")) {\n                generatedLineOffset--;\n\n                if (generatedColumnOffsetLine === line) {\n                  // undo exiting corrections form the current line\n                  generatedColumnOffset += generatedColumn;\n                }\n              } else if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset -= chunk.length - chunkPos;\n              } else {\n                generatedColumnOffset = chunkPos - chunk.length;\n                generatedColumnOffsetLine = line;\n              }\n\n              pos = endPos;\n              return;\n            } // Partially skip over chunk\n\n\n            const line = generatedLine + generatedLineOffset;\n\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n              originalColumn += offset;\n            }\n\n            chunkPos += offset;\n            pos += offset;\n\n            if (generatedColumnOffsetLine === line) {\n              generatedColumnOffset -= offset;\n            } else {\n              generatedColumnOffset = -offset;\n              generatedColumnOffsetLine = line;\n            }\n\n            generatedColumn += offset;\n          }\n        } while (nextReplacement < endPos);\n      } // Emit remaining chunk\n\n\n      if (chunkPos < chunk.length) {\n        const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n        const line = generatedLine + generatedLineOffset;\n        onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n      }\n\n      pos = endPos;\n    }, (sourceIndex, source, sourceContent) => {\n      while (sourceContents.length < sourceIndex) sourceContents.push(undefined);\n\n      sourceContents[sourceIndex] = sourceContent;\n      onSource(sourceIndex, source, sourceContent);\n    }, (nameIndex, name) => {\n      let globalIndex = nameMapping.get(name);\n\n      if (globalIndex === undefined) {\n        globalIndex = nameMapping.size;\n        nameMapping.set(name, globalIndex);\n        onName(globalIndex, name);\n      }\n\n      nameIndexMapping[nameIndex] = globalIndex;\n    }); // Handle remaining replacements\n\n    let remainer = \"\";\n\n    for (; i < repls.length; i++) {\n      remainer += repls[i].content;\n    } // Insert remaining replacements content splitted into chunks by lines\n\n\n    let line = generatedLine + generatedLineOffset;\n    let matches = splitIntoLines(remainer);\n\n    for (let m = 0; m < matches.length; m++) {\n      const contentLine = matches[m];\n      onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n\n      if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset += contentLine.length;\n        } else {\n          generatedColumnOffset = contentLine.length;\n          generatedColumnOffsetLine = line;\n        }\n      } else {\n        generatedLineOffset++;\n        line++;\n        generatedColumnOffset = -generatedColumn;\n        generatedColumnOffsetLine = line;\n      }\n    }\n\n    return {\n      generatedLine: line,\n      generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n    };\n  }\n\n  updateHash(hash) {\n    this._sortReplacements();\n\n    hash.update(\"ReplaceSource\");\n\n    this._source.updateHash(hash);\n\n    hash.update(this._name || \"\");\n\n    for (const repl of this._replacements) {\n      hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n    }\n  }\n\n}\n\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["getMap","getSourceAndMap","require","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","constructor","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","getName","getReplacements","_sortReplacements","replace","newValue","Error","push","insert","pos","length","current","result","replacement","Math","floor","offset","slice","join","map","options","sourceAndMap","original","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","generatedLine","generatedColumn","Object","assign","finalSource","chunk","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","updateHash","hash","update","module","exports"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\r\nconst streamChunks = require(\"./helpers/streamChunks\");\r\nconst Source = require(\"./Source\");\r\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\r\n\r\n// since v8 7.0, Array.prototype.sort is stable\r\nconst hasStableSort =\r\n\ttypeof process === \"object\" &&\r\n\tprocess.versions &&\r\n\ttypeof process.versions.v8 === \"string\" &&\r\n\t!/^[0-6]\\./.test(process.versions.v8);\r\n\r\n// This is larger than max string length\r\nconst MAX_SOURCE_POSITION = 0x20000000;\r\n\r\nclass Replacement {\r\n\tconstructor(start, end, content, name) {\r\n\t\tthis.start = start;\r\n\t\tthis.end = end;\r\n\t\tthis.content = content;\r\n\t\tthis.name = name;\r\n\t\tif (!hasStableSort) {\r\n\t\t\tthis.index = -1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass ReplaceSource extends Source {\r\n\tconstructor(source, name) {\r\n\t\tsuper();\r\n\t\tthis._source = source;\r\n\t\tthis._name = name;\r\n\t\t/** @type {Replacement[]} */\r\n\t\tthis._replacements = [];\r\n\t\tthis._isSorted = true;\r\n\t}\r\n\r\n\tgetName() {\r\n\t\treturn this._name;\r\n\t}\r\n\r\n\tgetReplacements() {\r\n\t\tthis._sortReplacements();\r\n\t\treturn this._replacements;\r\n\t}\r\n\r\n\treplace(start, end, newValue, name) {\r\n\t\tif (typeof newValue !== \"string\")\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\r\n\t\t\t);\r\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\r\n\t\tthis._isSorted = false;\r\n\t}\r\n\r\n\tinsert(pos, newValue, name) {\r\n\t\tif (typeof newValue !== \"string\")\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"insertion must be a string, but is a \" +\r\n\t\t\t\t\ttypeof newValue +\r\n\t\t\t\t\t\": \" +\r\n\t\t\t\t\tnewValue\r\n\t\t\t);\r\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\r\n\t\tthis._isSorted = false;\r\n\t}\r\n\r\n\tsource() {\r\n\t\tif (this._replacements.length === 0) {\r\n\t\t\treturn this._source.source();\r\n\t\t}\r\n\t\tlet current = this._source.source();\r\n\t\tlet pos = 0;\r\n\t\tconst result = [];\r\n\r\n\t\tthis._sortReplacements();\r\n\t\tfor (const replacement of this._replacements) {\r\n\t\t\tconst start = Math.floor(replacement.start);\r\n\t\t\tconst end = Math.floor(replacement.end + 1);\r\n\t\t\tif (pos < start) {\r\n\t\t\t\tconst offset = start - pos;\r\n\t\t\t\tresult.push(current.slice(0, offset));\r\n\t\t\t\tcurrent = current.slice(offset);\r\n\t\t\t\tpos = start;\r\n\t\t\t}\r\n\t\t\tresult.push(replacement.content);\r\n\t\t\tif (pos < end) {\r\n\t\t\t\tconst offset = end - pos;\r\n\t\t\t\tcurrent = current.slice(offset);\r\n\t\t\t\tpos = end;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(current);\r\n\t\treturn result.join(\"\");\r\n\t}\r\n\r\n\tmap(options) {\r\n\t\tif (this._replacements.length === 0) {\r\n\t\t\treturn this._source.map(options);\r\n\t\t}\r\n\t\treturn getMap(this, options);\r\n\t}\r\n\r\n\tsourceAndMap(options) {\r\n\t\tif (this._replacements.length === 0) {\r\n\t\t\treturn this._source.sourceAndMap(options);\r\n\t\t}\r\n\t\treturn getSourceAndMap(this, options);\r\n\t}\r\n\r\n\toriginal() {\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\t_sortReplacements() {\r\n\t\tif (this._isSorted) return;\r\n\t\tif (hasStableSort) {\r\n\t\t\tthis._replacements.sort(function (a, b) {\r\n\t\t\t\tconst diff1 = a.start - b.start;\r\n\t\t\t\tif (diff1 !== 0) return diff1;\r\n\t\t\t\tconst diff2 = a.end - b.end;\r\n\t\t\t\tif (diff2 !== 0) return diff2;\r\n\t\t\t\treturn 0;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\r\n\t\t\tthis._replacements.sort(function (a, b) {\r\n\t\t\t\tconst diff1 = a.start - b.start;\r\n\t\t\t\tif (diff1 !== 0) return diff1;\r\n\t\t\t\tconst diff2 = a.end - b.end;\r\n\t\t\t\tif (diff2 !== 0) return diff2;\r\n\t\t\t\treturn a.index - b.index;\r\n\t\t\t});\r\n\t\t}\r\n\t\tthis._isSorted = true;\r\n\t}\r\n\r\n\tstreamChunks(options, onChunk, onSource, onName) {\r\n\t\tthis._sortReplacements();\r\n\t\tconst repls = this._replacements;\r\n\t\tlet pos = 0;\r\n\t\tlet i = 0;\r\n\t\tlet replacmentEnd = -1;\r\n\t\tlet nextReplacement =\r\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\r\n\t\tlet generatedLineOffset = 0;\r\n\t\tlet generatedColumnOffset = 0;\r\n\t\tlet generatedColumnOffsetLine = 0;\r\n\t\tconst sourceContents = [];\r\n\t\tconst nameMapping = new Map();\r\n\t\tconst nameIndexMapping = [];\r\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\r\n\t\t\tlet content =\r\n\t\t\t\tsourceIndex < sourceContents.length\r\n\t\t\t\t\t? sourceContents[sourceIndex]\r\n\t\t\t\t\t: undefined;\r\n\t\t\tif (content === undefined) return false;\r\n\t\t\tif (typeof content === \"string\") {\r\n\t\t\t\tcontent = splitIntoLines(content);\r\n\t\t\t\tsourceContents[sourceIndex] = content;\r\n\t\t\t}\r\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\r\n\t\t\tif (contentLine === null) return false;\r\n\t\t\treturn (\r\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\r\n\t\t\t\texpectedChunk\r\n\t\t\t);\r\n\t\t};\r\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\r\n\t\t\tthis._source,\r\n\t\t\tObject.assign({}, options, { finalSource: false }),\r\n\t\t\t(\r\n\t\t\t\tchunk,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\tgeneratedColumn,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\tnameIndex\r\n\t\t\t) => {\r\n\t\t\t\tlet chunkPos = 0;\r\n\t\t\t\tlet endPos = pos + chunk.length;\r\n\r\n\t\t\t\t// Skip over when it has been replaced\r\n\t\t\t\tif (replacmentEnd > pos) {\r\n\t\t\t\t\t// Skip over the whole chunk\r\n\t\t\t\t\tif (replacmentEnd >= endPos) {\r\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\r\n\t\t\t\t\t\t\tgeneratedLineOffset--;\r\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\r\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpos = endPos;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Partially skip over chunk\r\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tcheckOriginalContent(\r\n\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\toriginalColumn += chunkPos;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos += chunkPos;\r\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\r\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgeneratedColumn += chunkPos;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is a replacement in the chunk?\r\n\t\t\t\tif (nextReplacement < endPos) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\t\tif (nextReplacement > pos) {\r\n\t\t\t\t\t\t\t// Emit chunk until replacement\r\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\r\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\r\n\t\t\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\t\t\tchunkSlice,\r\n\t\t\t\t\t\t\t\tline,\r\n\t\t\t\t\t\t\t\tgeneratedColumn +\r\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\r\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\r\n\t\t\t\t\t\t\t\t\t\t: 0),\r\n\t\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\r\n\t\t\t\t\t\t\t\t\t? -1\r\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tgeneratedColumn += offset;\r\n\t\t\t\t\t\t\tchunkPos += offset;\r\n\t\t\t\t\t\t\tpos = nextReplacement;\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tcheckOriginalContent(\r\n\t\t\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\t\tchunkSlice\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\r\n\t\t\t\t\t\tconst { content, name } = repls[i];\r\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\r\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\r\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\r\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\r\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\r\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\r\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\r\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\r\n\t\t\t\t\t\t\tconst contentLine = matches[m];\r\n\t\t\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\t\t\tcontentLine,\r\n\t\t\t\t\t\t\t\tline,\r\n\t\t\t\t\t\t\t\tgeneratedColumn +\r\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\r\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\r\n\t\t\t\t\t\t\t\t\t\t: 0),\r\n\t\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\treplacementNameIndex\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\r\n\t\t\t\t\t\t\treplacementNameIndex = -1;\r\n\r\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\r\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\r\n\t\t\t\t\t\t\t\tline++;\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Remove replaced content by settings this variable\r\n\t\t\t\t\t\treplacmentEnd = Math.max(\r\n\t\t\t\t\t\t\treplacmentEnd,\r\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t// Move to next replacment\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\tnextReplacement =\r\n\t\t\t\t\t\t\ti < repls.length\r\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\r\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\r\n\r\n\t\t\t\t\t\t// Skip over when it has been replaced\r\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\r\n\t\t\t\t\t\tif (offset > 0) {\r\n\t\t\t\t\t\t\t// Skip over whole chunk\r\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\r\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\r\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\r\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\r\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\r\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tpos = endPos;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Partially skip over chunk\r\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tcheckOriginalContent(\r\n\t\t\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\toriginalColumn += offset;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tchunkPos += offset;\r\n\t\t\t\t\t\t\tpos += offset;\r\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\r\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tgeneratedColumn += offset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (nextReplacement < endPos);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Emit remaining chunk\r\n\t\t\t\tif (chunkPos < chunk.length) {\r\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\r\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\r\n\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\tchunkSlice,\r\n\t\t\t\t\t\tline,\r\n\t\t\t\t\t\tgeneratedColumn +\r\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\r\n\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tpos = endPos;\r\n\t\t\t},\r\n\t\t\t(sourceIndex, source, sourceContent) => {\r\n\t\t\t\twhile (sourceContents.length < sourceIndex)\r\n\t\t\t\t\tsourceContents.push(undefined);\r\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\r\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\r\n\t\t\t},\r\n\t\t\t(nameIndex, name) => {\r\n\t\t\t\tlet globalIndex = nameMapping.get(name);\r\n\t\t\t\tif (globalIndex === undefined) {\r\n\t\t\t\t\tglobalIndex = nameMapping.size;\r\n\t\t\t\t\tnameMapping.set(name, globalIndex);\r\n\t\t\t\t\tonName(globalIndex, name);\r\n\t\t\t\t}\r\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Handle remaining replacements\r\n\t\tlet remainer = \"\";\r\n\t\tfor (; i < repls.length; i++) {\r\n\t\t\tremainer += repls[i].content;\r\n\t\t}\r\n\r\n\t\t// Insert remaining replacements content splitted into chunks by lines\r\n\t\tlet line = generatedLine + generatedLineOffset;\r\n\t\tlet matches = splitIntoLines(remainer);\r\n\t\tfor (let m = 0; m < matches.length; m++) {\r\n\t\t\tconst contentLine = matches[m];\r\n\t\t\tonChunk(\r\n\t\t\t\tcontentLine,\r\n\t\t\t\tline,\r\n\t\t\t\tgeneratedColumn +\r\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\r\n\t\t\t\t-1,\r\n\t\t\t\t-1,\r\n\t\t\t\t-1,\r\n\t\t\t\t-1\r\n\t\t\t);\r\n\r\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\r\n\t\t\t\tif (generatedColumnOffsetLine === line) {\r\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\r\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tgeneratedLineOffset++;\r\n\t\t\t\tline++;\r\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\r\n\t\t\t\tgeneratedColumnOffsetLine = line;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tgeneratedLine: line,\r\n\t\t\tgeneratedColumn:\r\n\t\t\t\tgeneratedColumn +\r\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\r\n\t\t};\r\n\t}\r\n\r\n\tupdateHash(hash) {\r\n\t\tthis._sortReplacements();\r\n\t\thash.update(\"ReplaceSource\");\r\n\t\tthis._source.updateHash(hash);\r\n\t\thash.update(this._name || \"\");\r\n\t\tfor (const repl of this._replacements) {\r\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = ReplaceSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}