{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n\nvar util = require('./util'); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\n\n\nvar REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\nvar NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\n\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\n\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\n\n\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n  // The SourceNode we want to fill with the generated code\n  // and the SourceMap\n  var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n  // while all odd indices are the newlines between two adjacent lines\n  // (since `REGEX_NEWLINE` captures its match).\n  // Processed fragments are accessed by calling `shiftNextLine`.\n\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n  var remainingLinesIndex = 0;\n\n  var shiftNextLine = function () {\n    var lineContents = getNextLine(); // The last line of a file might not have a newline.\n\n    var newLine = getNextLine() || \"\";\n    return lineContents + newLine;\n\n    function getNextLine() {\n      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n    }\n  }; // We need to remember the position of \"remainingLines\"\n\n\n  var lastGeneratedLine = 1,\n      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n  // To extract it current and last mapping is used.\n  // Here we store the last mapping.\n\n  var lastMapping = null;\n  aSourceMapConsumer.eachMapping(function (mapping) {\n    if (lastMapping !== null) {\n      // We add the code from \"lastMapping\" to \"mapping\":\n      // First check if there is a new line in between.\n      if (lastGeneratedLine < mapping.generatedLine) {\n        // Associate first line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n        lastGeneratedLine++;\n        lastGeneratedColumn = 0; // The remaining code is added without mapping\n      } else {\n        // There is no new line in between.\n        // Associate the code between \"lastGeneratedColumn\" and\n        // \"mapping.generatedColumn\" with \"lastMapping\"\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n        addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n        lastMapping = mapping;\n        return;\n      }\n    } // We add the generated code until the first mapping\n    // to the SourceNode without any mapping.\n    // Each line is added as separate string.\n\n\n    while (lastGeneratedLine < mapping.generatedLine) {\n      node.add(shiftNextLine());\n      lastGeneratedLine++;\n    }\n\n    if (lastGeneratedColumn < mapping.generatedColumn) {\n      var nextLine = remainingLines[remainingLinesIndex] || '';\n      node.add(nextLine.substr(0, mapping.generatedColumn));\n      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n      lastGeneratedColumn = mapping.generatedColumn;\n    }\n\n    lastMapping = mapping;\n  }, this); // We have processed all mappings.\n\n  if (remainingLinesIndex < remainingLines.length) {\n    if (lastMapping) {\n      // Associate the remaining code in the current line with \"lastMapping\"\n      addMappingWithCode(lastMapping, shiftNextLine());\n    } // and add the remaining lines without any mapping\n\n\n    node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n  } // Copy sourcesContent into SourceNode\n\n\n  aSourceMapConsumer.sources.forEach(function (sourceFile) {\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n    if (content != null) {\n      if (aRelativePath != null) {\n        sourceFile = util.join(aRelativePath, sourceFile);\n      }\n\n      node.setSourceContent(sourceFile, content);\n    }\n  });\n  return node;\n\n  function addMappingWithCode(mapping, code) {\n    if (mapping === null || mapping.source === undefined) {\n      node.add(code);\n    } else {\n      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n    }\n  }\n};\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\n\n\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\n\n\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length - 1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\n\n\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    } else {\n      if (chunk !== '') {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n};\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\n\n\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n\n  if (len > 0) {\n    newChildren = [];\n\n    for (i = 0; i < len - 1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n\n  return this;\n};\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\n\n\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  } else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  } else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n\n  return this;\n};\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\n\n\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\n\n\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    if (this.children[i][isSourceNode]) {\n      this.children[i].walkSourceContents(aFn);\n    }\n  }\n\n  var sources = Object.keys(this.sourceContents);\n\n  for (var i = 0, len = sources.length; i < len; i++) {\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n  }\n};\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\n\n\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\n\n\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n\n    if (original.source !== null && original.line !== null && original.column !== null) {\n      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0; // Mappings end at eol\n\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n  return {\n    code: generated.code,\n    map: map\n  };\n};\n\nexports.SourceNode = SourceNode;","map":{"version":3,"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\r\nvar util = require('./util');\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap =\r\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\r\n    // The SourceNode we want to fill with the generated code\r\n    // and the SourceMap\r\n    var node = new SourceNode();\r\n\r\n    // All even indices of this array are one line of the generated code,\r\n    // while all odd indices are the newlines between two adjacent lines\r\n    // (since `REGEX_NEWLINE` captures its match).\r\n    // Processed fragments are accessed by calling `shiftNextLine`.\r\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n    var remainingLinesIndex = 0;\r\n    var shiftNextLine = function() {\r\n      var lineContents = getNextLine();\r\n      // The last line of a file might not have a newline.\r\n      var newLine = getNextLine() || \"\";\r\n      return lineContents + newLine;\r\n\r\n      function getNextLine() {\r\n        return remainingLinesIndex < remainingLines.length ?\r\n            remainingLines[remainingLinesIndex++] : undefined;\r\n      }\r\n    };\r\n\r\n    // We need to remember the position of \"remainingLines\"\r\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\r\n\r\n    // The generate SourceNodes we need a code range.\r\n    // To extract it current and last mapping is used.\r\n    // Here we store the last mapping.\r\n    var lastMapping = null;\r\n\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      if (lastMapping !== null) {\r\n        // We add the code from \"lastMapping\" to \"mapping\":\r\n        // First check if there is a new line in between.\r\n        if (lastGeneratedLine < mapping.generatedLine) {\r\n          // Associate first line with \"lastMapping\"\r\n          addMappingWithCode(lastMapping, shiftNextLine());\r\n          lastGeneratedLine++;\r\n          lastGeneratedColumn = 0;\r\n          // The remaining code is added without mapping\r\n        } else {\r\n          // There is no new line in between.\r\n          // Associate the code between \"lastGeneratedColumn\" and\r\n          // \"mapping.generatedColumn\" with \"lastMapping\"\r\n          var nextLine = remainingLines[remainingLinesIndex] || '';\r\n          var code = nextLine.substr(0, mapping.generatedColumn -\r\n                                        lastGeneratedColumn);\r\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\r\n                                              lastGeneratedColumn);\r\n          lastGeneratedColumn = mapping.generatedColumn;\r\n          addMappingWithCode(lastMapping, code);\r\n          // No more remaining code, continue\r\n          lastMapping = mapping;\r\n          return;\r\n        }\r\n      }\r\n      // We add the generated code until the first mapping\r\n      // to the SourceNode without any mapping.\r\n      // Each line is added as separate string.\r\n      while (lastGeneratedLine < mapping.generatedLine) {\r\n        node.add(shiftNextLine());\r\n        lastGeneratedLine++;\r\n      }\r\n      if (lastGeneratedColumn < mapping.generatedColumn) {\r\n        var nextLine = remainingLines[remainingLinesIndex] || '';\r\n        node.add(nextLine.substr(0, mapping.generatedColumn));\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n      }\r\n      lastMapping = mapping;\r\n    }, this);\r\n    // We have processed all mappings.\r\n    if (remainingLinesIndex < remainingLines.length) {\r\n      if (lastMapping) {\r\n        // Associate the remaining code in the current line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n      }\r\n      // and add the remaining lines without any mapping\r\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n    }\r\n\r\n    // Copy sourcesContent into SourceNode\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aRelativePath != null) {\r\n          sourceFile = util.join(aRelativePath, sourceFile);\r\n        }\r\n        node.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n\r\n    return node;\r\n\r\n    function addMappingWithCode(mapping, code) {\r\n      if (mapping === null || mapping.source === undefined) {\r\n        node.add(code);\r\n      } else {\r\n        var source = aRelativePath\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n        node.add(new SourceNode(mapping.originalLine,\r\n                                mapping.originalColumn,\r\n                                source,\r\n                                code,\r\n                                mapping.name));\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function (chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length-1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    }\r\n    else {\r\n      if (chunk !== '') {\r\n        aFn(chunk, { source: this.source,\r\n                     line: this.line,\r\n                     column: this.column,\r\n                     name: this.name });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len-1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  }\r\n  else if (typeof lastChild === 'string') {\r\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\r\n  }\r\n  else {\r\n    this.children.push(''.replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent =\r\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\r\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n  };\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents =\r\n  function SourceNode_walkSourceContents(aFn) {\r\n    for (var i = 0, len = this.children.length; i < len; i++) {\r\n      if (this.children[i][isSourceNode]) {\r\n        this.children[i].walkSourceContents(aFn);\r\n      }\r\n    }\r\n\r\n    var sources = Object.keys(this.sourceContents);\r\n    for (var i = 0, len = sources.length; i < len; i++) {\r\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n    }\r\n  };\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function (chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function (chunk, original) {\r\n    generated.code += chunk;\r\n    if (original.source !== null\r\n        && original.line !== null\r\n        && original.column !== null) {\r\n      if(lastOriginalSource !== original.source\r\n         || lastOriginalLine !== original.line\r\n         || lastOriginalColumn !== original.column\r\n         || lastOriginalName !== original.name) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function (sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}