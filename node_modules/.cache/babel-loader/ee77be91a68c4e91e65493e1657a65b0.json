{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\n\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\n\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nconst mapToBufferedMap = map => {\n  if (typeof map !== \"object\" || !map) return map;\n  const bufferedMap = Object.assign({}, map);\n\n  if (map.mappings) {\n    bufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n  }\n\n  if (map.sourcesContent) {\n    bufferedMap.sourcesContent = map.sourcesContent.map(str => str && Buffer.from(str, \"utf-8\"));\n  }\n\n  return bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n  if (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n  const map = Object.assign({}, bufferedMap);\n\n  if (bufferedMap.mappings) {\n    map.mappings = bufferedMap.mappings.toString(\"utf-8\");\n  }\n\n  if (bufferedMap.sourcesContent) {\n    map.sourcesContent = bufferedMap.sourcesContent.map(buffer => buffer && buffer.toString(\"utf-8\"));\n  }\n\n  return map;\n};\n\nclass CachedSource extends Source {\n  constructor(source, cachedData) {\n    super();\n    this._source = source;\n    this._cachedSourceType = cachedData ? cachedData.source : undefined;\n    this._cachedSource = undefined;\n    this._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n    this._cachedSize = cachedData ? cachedData.size : undefined;\n    this._cachedMaps = cachedData ? cachedData.maps : new Map();\n    this._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n  }\n\n  getCachedData() {\n    const bufferedMaps = new Map();\n\n    for (const pair of this._cachedMaps) {\n      let cacheEntry = pair[1];\n\n      if (cacheEntry.bufferedMap === undefined) {\n        cacheEntry.bufferedMap = mapToBufferedMap(this._getMapFromCacheEntry(cacheEntry));\n      }\n\n      bufferedMaps.set(pair[0], {\n        map: undefined,\n        bufferedMap: cacheEntry.bufferedMap\n      });\n    } // We don't want to cache strings\n    // So if we have a caches sources\n    // create a buffer from it and only store\n    // if it was a Buffer or string\n\n\n    if (this._cachedSource) {\n      this.buffer();\n    }\n\n    return {\n      buffer: this._cachedBuffer,\n      source: this._cachedSourceType !== undefined ? this._cachedSourceType : typeof this._cachedSource === \"string\" ? true : Buffer.isBuffer(this._cachedSource) ? false : undefined,\n      size: this._cachedSize,\n      maps: bufferedMaps,\n      hash: this._cachedHashUpdate\n    };\n  }\n\n  originalLazy() {\n    return this._source;\n  }\n\n  original() {\n    if (typeof this._source === \"function\") this._source = this._source();\n    return this._source;\n  }\n\n  source() {\n    const source = this._getCachedSource();\n\n    if (source !== undefined) return source;\n    return this._cachedSource = this.original().source();\n  }\n\n  _getMapFromCacheEntry(cacheEntry) {\n    if (cacheEntry.map !== undefined) {\n      return cacheEntry.map;\n    } else if (cacheEntry.bufferedMap !== undefined) {\n      return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);\n    }\n  }\n\n  _getCachedSource() {\n    if (this._cachedSource !== undefined) return this._cachedSource;\n\n    if (this._cachedBuffer && this._cachedSourceType !== undefined) {\n      return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString(\"utf-8\") : this._cachedBuffer;\n    }\n  }\n\n  buffer() {\n    if (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\n    if (this._cachedSource !== undefined) {\n      if (Buffer.isBuffer(this._cachedSource)) {\n        return this._cachedBuffer = this._cachedSource;\n      }\n\n      return this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\");\n    }\n\n    if (typeof this.original().buffer === \"function\") {\n      return this._cachedBuffer = this.original().buffer();\n    }\n\n    const bufferOrString = this.source();\n\n    if (Buffer.isBuffer(bufferOrString)) {\n      return this._cachedBuffer = bufferOrString;\n    }\n\n    return this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\");\n  }\n\n  size() {\n    if (this._cachedSize !== undefined) return this._cachedSize;\n\n    if (this._cachedBuffer !== undefined) {\n      return this._cachedSize = this._cachedBuffer.length;\n    }\n\n    const source = this._getCachedSource();\n\n    if (source !== undefined) {\n      return this._cachedSize = Buffer.byteLength(source);\n    }\n\n    return this._cachedSize = this.original().size();\n  }\n\n  sourceAndMap(options) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    const cacheEntry = this._cachedMaps.get(key); // Look for a cached map\n\n\n    if (cacheEntry !== undefined) {\n      // We have a cached map in some representation\n      const map = this._getMapFromCacheEntry(cacheEntry); // Either get the cached source or compute it\n\n\n      return {\n        source: this.source(),\n        map\n      };\n    } // Look for a cached source\n\n\n    let source = this._getCachedSource(); // Compute the map\n\n\n    let map;\n\n    if (source !== undefined) {\n      map = this.original().map(options);\n    } else {\n      // Compute the source and map together.\n      const sourceAndMap = this.original().sourceAndMap(options);\n      source = sourceAndMap.source;\n      map = sourceAndMap.map;\n      this._cachedSource = source;\n    }\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return {\n      source,\n      map\n    };\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    if (this._cachedMaps.has(key) && (this._cachedBuffer !== undefined || this._cachedSource !== undefined)) {\n      const {\n        source,\n        map\n      } = this.sourceAndMap(options);\n\n      if (map) {\n        return streamChunksOfSourceMap(source, map, onChunk, onSource, onName, !!(options && options.finalSource), true);\n      } else {\n        return streamChunksOfRawSource(source, onChunk, onSource, onName, !!(options && options.finalSource));\n      }\n    }\n\n    const {\n      result,\n      source,\n      map\n    } = streamAndGetSourceAndMap(this.original(), options, onChunk, onSource, onName);\n    this._cachedSource = source;\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return result;\n  }\n\n  map(options) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    const cacheEntry = this._cachedMaps.get(key);\n\n    if (cacheEntry !== undefined) {\n      return this._getMapFromCacheEntry(cacheEntry);\n    }\n\n    const map = this.original().map(options);\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return map;\n  }\n\n  updateHash(hash) {\n    if (this._cachedHashUpdate !== undefined) {\n      for (const item of this._cachedHashUpdate) hash.update(item);\n\n      return;\n    }\n\n    const update = [];\n    let currentString = undefined;\n    const tracker = {\n      update: item => {\n        if (typeof item === \"string\" && item.length < 10240) {\n          if (currentString === undefined) {\n            currentString = item;\n          } else {\n            currentString += item;\n\n            if (currentString.length > 102400) {\n              update.push(Buffer.from(currentString));\n              currentString = undefined;\n            }\n          }\n        } else {\n          if (currentString !== undefined) {\n            update.push(Buffer.from(currentString));\n            currentString = undefined;\n          }\n\n          update.push(item);\n        }\n      }\n    };\n    this.original().updateHash(tracker);\n\n    if (currentString !== undefined) {\n      update.push(Buffer.from(currentString));\n    }\n\n    for (const item of update) hash.update(item);\n\n    this._cachedHashUpdate = update;\n  }\n\n}\n\nmodule.exports = CachedSource;","map":{"version":3,"names":["Source","require","streamChunksOfSourceMap","streamChunksOfRawSource","streamAndGetSourceAndMap","mapToBufferedMap","map","bufferedMap","Object","assign","mappings","Buffer","from","sourcesContent","str","bufferedMapToMap","toString","buffer","CachedSource","constructor","source","cachedData","_source","_cachedSourceType","undefined","_cachedSource","_cachedBuffer","_cachedSize","size","_cachedMaps","maps","Map","_cachedHashUpdate","hash","getCachedData","bufferedMaps","pair","cacheEntry","_getMapFromCacheEntry","set","isBuffer","originalLazy","original","_getCachedSource","bufferOrString","length","byteLength","sourceAndMap","options","key","JSON","stringify","get","streamChunks","onChunk","onSource","onName","has","finalSource","result","updateHash","item","update","currentString","tracker","push","module","exports"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/webpack-sources/lib/CachedSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst Source = require(\"./Source\");\r\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\r\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\r\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\r\n\r\nconst mapToBufferedMap = map => {\r\n\tif (typeof map !== \"object\" || !map) return map;\r\n\tconst bufferedMap = Object.assign({}, map);\r\n\tif (map.mappings) {\r\n\t\tbufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\r\n\t}\r\n\tif (map.sourcesContent) {\r\n\t\tbufferedMap.sourcesContent = map.sourcesContent.map(\r\n\t\t\tstr => str && Buffer.from(str, \"utf-8\")\r\n\t\t);\r\n\t}\r\n\treturn bufferedMap;\r\n};\r\n\r\nconst bufferedMapToMap = bufferedMap => {\r\n\tif (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\r\n\tconst map = Object.assign({}, bufferedMap);\r\n\tif (bufferedMap.mappings) {\r\n\t\tmap.mappings = bufferedMap.mappings.toString(\"utf-8\");\r\n\t}\r\n\tif (bufferedMap.sourcesContent) {\r\n\t\tmap.sourcesContent = bufferedMap.sourcesContent.map(\r\n\t\t\tbuffer => buffer && buffer.toString(\"utf-8\")\r\n\t\t);\r\n\t}\r\n\treturn map;\r\n};\r\n\r\nclass CachedSource extends Source {\r\n\tconstructor(source, cachedData) {\r\n\t\tsuper();\r\n\t\tthis._source = source;\r\n\t\tthis._cachedSourceType = cachedData ? cachedData.source : undefined;\r\n\t\tthis._cachedSource = undefined;\r\n\t\tthis._cachedBuffer = cachedData ? cachedData.buffer : undefined;\r\n\t\tthis._cachedSize = cachedData ? cachedData.size : undefined;\r\n\t\tthis._cachedMaps = cachedData ? cachedData.maps : new Map();\r\n\t\tthis._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\r\n\t}\r\n\r\n\tgetCachedData() {\r\n\t\tconst bufferedMaps = new Map();\r\n\t\tfor (const pair of this._cachedMaps) {\r\n\t\t\tlet cacheEntry = pair[1];\r\n\t\t\tif (cacheEntry.bufferedMap === undefined) {\r\n\t\t\t\tcacheEntry.bufferedMap = mapToBufferedMap(\r\n\t\t\t\t\tthis._getMapFromCacheEntry(cacheEntry)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tbufferedMaps.set(pair[0], {\r\n\t\t\t\tmap: undefined,\r\n\t\t\t\tbufferedMap: cacheEntry.bufferedMap\r\n\t\t\t});\r\n\t\t}\r\n\t\t// We don't want to cache strings\r\n\t\t// So if we have a caches sources\r\n\t\t// create a buffer from it and only store\r\n\t\t// if it was a Buffer or string\r\n\t\tif (this._cachedSource) {\r\n\t\t\tthis.buffer();\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tbuffer: this._cachedBuffer,\r\n\t\t\tsource:\r\n\t\t\t\tthis._cachedSourceType !== undefined\r\n\t\t\t\t\t? this._cachedSourceType\r\n\t\t\t\t\t: typeof this._cachedSource === \"string\"\r\n\t\t\t\t\t? true\r\n\t\t\t\t\t: Buffer.isBuffer(this._cachedSource)\r\n\t\t\t\t\t? false\r\n\t\t\t\t\t: undefined,\r\n\t\t\tsize: this._cachedSize,\r\n\t\t\tmaps: bufferedMaps,\r\n\t\t\thash: this._cachedHashUpdate\r\n\t\t};\r\n\t}\r\n\r\n\toriginalLazy() {\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\toriginal() {\r\n\t\tif (typeof this._source === \"function\") this._source = this._source();\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\tsource() {\r\n\t\tconst source = this._getCachedSource();\r\n\t\tif (source !== undefined) return source;\r\n\t\treturn (this._cachedSource = this.original().source());\r\n\t}\r\n\r\n\t_getMapFromCacheEntry(cacheEntry) {\r\n\t\tif (cacheEntry.map !== undefined) {\r\n\t\t\treturn cacheEntry.map;\r\n\t\t} else if (cacheEntry.bufferedMap !== undefined) {\r\n\t\t\treturn (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));\r\n\t\t}\r\n\t}\r\n\r\n\t_getCachedSource() {\r\n\t\tif (this._cachedSource !== undefined) return this._cachedSource;\r\n\t\tif (this._cachedBuffer && this._cachedSourceType !== undefined) {\r\n\t\t\treturn (this._cachedSource = this._cachedSourceType\r\n\t\t\t\t? this._cachedBuffer.toString(\"utf-8\")\r\n\t\t\t\t: this._cachedBuffer);\r\n\t\t}\r\n\t}\r\n\r\n\tbuffer() {\r\n\t\tif (this._cachedBuffer !== undefined) return this._cachedBuffer;\r\n\t\tif (this._cachedSource !== undefined) {\r\n\t\t\tif (Buffer.isBuffer(this._cachedSource)) {\r\n\t\t\t\treturn (this._cachedBuffer = this._cachedSource);\r\n\t\t\t}\r\n\t\t\treturn (this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\"));\r\n\t\t}\r\n\t\tif (typeof this.original().buffer === \"function\") {\r\n\t\t\treturn (this._cachedBuffer = this.original().buffer());\r\n\t\t}\r\n\t\tconst bufferOrString = this.source();\r\n\t\tif (Buffer.isBuffer(bufferOrString)) {\r\n\t\t\treturn (this._cachedBuffer = bufferOrString);\r\n\t\t}\r\n\t\treturn (this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\"));\r\n\t}\r\n\r\n\tsize() {\r\n\t\tif (this._cachedSize !== undefined) return this._cachedSize;\r\n\t\tif (this._cachedBuffer !== undefined) {\r\n\t\t\treturn (this._cachedSize = this._cachedBuffer.length);\r\n\t\t}\r\n\t\tconst source = this._getCachedSource();\r\n\t\tif (source !== undefined) {\r\n\t\t\treturn (this._cachedSize = Buffer.byteLength(source));\r\n\t\t}\r\n\t\treturn (this._cachedSize = this.original().size());\r\n\t}\r\n\r\n\tsourceAndMap(options) {\r\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\r\n\t\tconst cacheEntry = this._cachedMaps.get(key);\r\n\t\t// Look for a cached map\r\n\t\tif (cacheEntry !== undefined) {\r\n\t\t\t// We have a cached map in some representation\r\n\t\t\tconst map = this._getMapFromCacheEntry(cacheEntry);\r\n\t\t\t// Either get the cached source or compute it\r\n\t\t\treturn { source: this.source(), map };\r\n\t\t}\r\n\t\t// Look for a cached source\r\n\t\tlet source = this._getCachedSource();\r\n\t\t// Compute the map\r\n\t\tlet map;\r\n\t\tif (source !== undefined) {\r\n\t\t\tmap = this.original().map(options);\r\n\t\t} else {\r\n\t\t\t// Compute the source and map together.\r\n\t\t\tconst sourceAndMap = this.original().sourceAndMap(options);\r\n\t\t\tsource = sourceAndMap.source;\r\n\t\t\tmap = sourceAndMap.map;\r\n\t\t\tthis._cachedSource = source;\r\n\t\t}\r\n\t\tthis._cachedMaps.set(key, {\r\n\t\t\tmap,\r\n\t\t\tbufferedMap: undefined\r\n\t\t});\r\n\t\treturn { source, map };\r\n\t}\r\n\r\n\tstreamChunks(options, onChunk, onSource, onName) {\r\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\r\n\t\tif (\r\n\t\t\tthis._cachedMaps.has(key) &&\r\n\t\t\t(this._cachedBuffer !== undefined || this._cachedSource !== undefined)\r\n\t\t) {\r\n\t\t\tconst { source, map } = this.sourceAndMap(options);\r\n\t\t\tif (map) {\r\n\t\t\t\treturn streamChunksOfSourceMap(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tmap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName,\r\n\t\t\t\t\t!!(options && options.finalSource),\r\n\t\t\t\t\ttrue\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\treturn streamChunksOfRawSource(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName,\r\n\t\t\t\t\t!!(options && options.finalSource)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst { result, source, map } = streamAndGetSourceAndMap(\r\n\t\t\tthis.original(),\r\n\t\t\toptions,\r\n\t\t\tonChunk,\r\n\t\t\tonSource,\r\n\t\t\tonName\r\n\t\t);\r\n\t\tthis._cachedSource = source;\r\n\t\tthis._cachedMaps.set(key, {\r\n\t\t\tmap,\r\n\t\t\tbufferedMap: undefined\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\tmap(options) {\r\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\r\n\t\tconst cacheEntry = this._cachedMaps.get(key);\r\n\t\tif (cacheEntry !== undefined) {\r\n\t\t\treturn this._getMapFromCacheEntry(cacheEntry);\r\n\t\t}\r\n\t\tconst map = this.original().map(options);\r\n\t\tthis._cachedMaps.set(key, {\r\n\t\t\tmap,\r\n\t\t\tbufferedMap: undefined\r\n\t\t});\r\n\t\treturn map;\r\n\t}\r\n\r\n\tupdateHash(hash) {\r\n\t\tif (this._cachedHashUpdate !== undefined) {\r\n\t\t\tfor (const item of this._cachedHashUpdate) hash.update(item);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst update = [];\r\n\t\tlet currentString = undefined;\r\n\t\tconst tracker = {\r\n\t\t\tupdate: item => {\r\n\t\t\t\tif (typeof item === \"string\" && item.length < 10240) {\r\n\t\t\t\t\tif (currentString === undefined) {\r\n\t\t\t\t\t\tcurrentString = item;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentString += item;\r\n\t\t\t\t\t\tif (currentString.length > 102400) {\r\n\t\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\r\n\t\t\t\t\t\t\tcurrentString = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (currentString !== undefined) {\r\n\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\r\n\t\t\t\t\t\tcurrentString = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdate.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.original().updateHash(tracker);\r\n\t\tif (currentString !== undefined) {\r\n\t\t\tupdate.push(Buffer.from(currentString));\r\n\t\t}\r\n\t\tfor (const item of update) hash.update(item);\r\n\t\tthis._cachedHashUpdate = update;\r\n\t}\r\n}\r\n\r\nmodule.exports = CachedSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}