{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n/**\r\n * @template T\r\n * @typedef {Object} TreeNode\r\n * @property {string} filePath\r\n * @property {TreeNode} parent\r\n * @property {TreeNode[]} children\r\n * @property {number} entries\r\n * @property {boolean} active\r\n * @property {T[] | T | undefined} value\r\n */\n\n/**\r\n * @template T\r\n * @param {Map<string, T[] | T} plan\r\n * @param {number} limit\r\n * @returns {Map<string, Map<T, string>>} the new plan\r\n */\n\n\nmodule.exports = (plan, limit) => {\n  const treeMap = new Map(); // Convert to tree\n\n  for (const [filePath, value] of plan) {\n    treeMap.set(filePath, {\n      filePath,\n      parent: undefined,\n      children: undefined,\n      entries: 1,\n      active: true,\n      value\n    });\n  }\n\n  let currentCount = treeMap.size; // Create parents and calculate sum of entries\n\n  for (const node of treeMap.values()) {\n    const parentPath = path.dirname(node.filePath);\n\n    if (parentPath !== node.filePath) {\n      let parent = treeMap.get(parentPath);\n\n      if (parent === undefined) {\n        parent = {\n          filePath: parentPath,\n          parent: undefined,\n          children: [node],\n          entries: node.entries,\n          active: false,\n          value: undefined\n        };\n        treeMap.set(parentPath, parent);\n        node.parent = parent;\n      } else {\n        node.parent = parent;\n\n        if (parent.children === undefined) {\n          parent.children = [node];\n        } else {\n          parent.children.push(node);\n        }\n\n        do {\n          parent.entries += node.entries;\n          parent = parent.parent;\n        } while (parent);\n      }\n    }\n  } // Reduce until limit reached\n\n\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    const overLimit = currentCount - limit;\n    let bestNode = undefined;\n    let bestCost = Infinity;\n\n    for (const node of treeMap.values()) {\n      if (node.entries <= 1 || !node.children || !node.parent) continue;\n      if (node.children.length === 0) continue;\n      if (node.children.length === 1 && !node.value) continue; // Try to select the node with has just a bit more entries than we need to reduce\n      // When just a bit more is over 30% over the limit,\n      // also consider just a bit less entries then we need to reduce\n\n      const cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n\n      if (cost < bestCost) {\n        bestNode = node;\n        bestCost = cost;\n      }\n    }\n\n    if (!bestNode) break; // Merge all children\n\n    const reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    let parent = bestNode.parent;\n\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n\n    const queue = new Set(bestNode.children);\n\n    for (const node of queue) {\n      node.active = false;\n      node.entries = 0;\n\n      if (node.children) {\n        for (const child of node.children) queue.add(child);\n      }\n    }\n  } // Write down new plan\n\n\n  const newPlan = new Map();\n\n  for (const rootNode of treeMap.values()) {\n    if (!rootNode.active) continue;\n    const map = new Map();\n    const queue = new Set([rootNode]);\n\n    for (const node of queue) {\n      if (node.active && node !== rootNode) continue;\n\n      if (node.value) {\n        if (Array.isArray(node.value)) {\n          for (const item of node.value) {\n            map.set(item, node.filePath);\n          }\n        } else {\n          map.set(node.value, node.filePath);\n        }\n      }\n\n      if (node.children) {\n        for (const child of node.children) {\n          queue.add(child);\n        }\n      }\n    }\n\n    newPlan.set(rootNode.filePath, map);\n  }\n\n  return newPlan;\n};","map":{"version":3,"names":["path","require","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","node","values","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/watchpack/lib/reducePlan.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst path = require(\"path\");\r\n\r\n/**\r\n * @template T\r\n * @typedef {Object} TreeNode\r\n * @property {string} filePath\r\n * @property {TreeNode} parent\r\n * @property {TreeNode[]} children\r\n * @property {number} entries\r\n * @property {boolean} active\r\n * @property {T[] | T | undefined} value\r\n */\r\n\r\n/**\r\n * @template T\r\n * @param {Map<string, T[] | T} plan\r\n * @param {number} limit\r\n * @returns {Map<string, Map<T, string>>} the new plan\r\n */\r\nmodule.exports = (plan, limit) => {\r\n\tconst treeMap = new Map();\r\n\t// Convert to tree\r\n\tfor (const [filePath, value] of plan) {\r\n\t\ttreeMap.set(filePath, {\r\n\t\t\tfilePath,\r\n\t\t\tparent: undefined,\r\n\t\t\tchildren: undefined,\r\n\t\t\tentries: 1,\r\n\t\t\tactive: true,\r\n\t\t\tvalue\r\n\t\t});\r\n\t}\r\n\tlet currentCount = treeMap.size;\r\n\t// Create parents and calculate sum of entries\r\n\tfor (const node of treeMap.values()) {\r\n\t\tconst parentPath = path.dirname(node.filePath);\r\n\t\tif (parentPath !== node.filePath) {\r\n\t\t\tlet parent = treeMap.get(parentPath);\r\n\t\t\tif (parent === undefined) {\r\n\t\t\t\tparent = {\r\n\t\t\t\t\tfilePath: parentPath,\r\n\t\t\t\t\tparent: undefined,\r\n\t\t\t\t\tchildren: [node],\r\n\t\t\t\t\tentries: node.entries,\r\n\t\t\t\t\tactive: false,\r\n\t\t\t\t\tvalue: undefined\r\n\t\t\t\t};\r\n\t\t\t\ttreeMap.set(parentPath, parent);\r\n\t\t\t\tnode.parent = parent;\r\n\t\t\t} else {\r\n\t\t\t\tnode.parent = parent;\r\n\t\t\t\tif (parent.children === undefined) {\r\n\t\t\t\t\tparent.children = [node];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.children.push(node);\r\n\t\t\t\t}\r\n\t\t\t\tdo {\r\n\t\t\t\t\tparent.entries += node.entries;\r\n\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t} while (parent);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Reduce until limit reached\r\n\twhile (currentCount > limit) {\r\n\t\t// Select node that helps reaching the limit most effectively without overmerging\r\n\t\tconst overLimit = currentCount - limit;\r\n\t\tlet bestNode = undefined;\r\n\t\tlet bestCost = Infinity;\r\n\t\tfor (const node of treeMap.values()) {\r\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\r\n\t\t\tif (node.children.length === 0) continue;\r\n\t\t\tif (node.children.length === 1 && !node.value) continue;\r\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\r\n\t\t\t// When just a bit more is over 30% over the limit,\r\n\t\t\t// also consider just a bit less entries then we need to reduce\r\n\t\t\tconst cost =\r\n\t\t\t\tnode.entries - 1 >= overLimit\r\n\t\t\t\t\t? node.entries - 1 - overLimit\r\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\r\n\t\t\tif (cost < bestCost) {\r\n\t\t\t\tbestNode = node;\r\n\t\t\t\tbestCost = cost;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!bestNode) break;\r\n\t\t// Merge all children\r\n\t\tconst reduction = bestNode.entries - 1;\r\n\t\tbestNode.active = true;\r\n\t\tbestNode.entries = 1;\r\n\t\tcurrentCount -= reduction;\r\n\t\tlet parent = bestNode.parent;\r\n\t\twhile (parent) {\r\n\t\t\tparent.entries -= reduction;\r\n\t\t\tparent = parent.parent;\r\n\t\t}\r\n\t\tconst queue = new Set(bestNode.children);\r\n\t\tfor (const node of queue) {\r\n\t\t\tnode.active = false;\r\n\t\t\tnode.entries = 0;\r\n\t\t\tif (node.children) {\r\n\t\t\t\tfor (const child of node.children) queue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Write down new plan\r\n\tconst newPlan = new Map();\r\n\tfor (const rootNode of treeMap.values()) {\r\n\t\tif (!rootNode.active) continue;\r\n\t\tconst map = new Map();\r\n\t\tconst queue = new Set([rootNode]);\r\n\t\tfor (const node of queue) {\r\n\t\t\tif (node.active && node !== rootNode) continue;\r\n\t\t\tif (node.value) {\r\n\t\t\t\tif (Array.isArray(node.value)) {\r\n\t\t\t\t\tfor (const item of node.value) {\r\n\t\t\t\t\t\tmap.set(item, node.filePath);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmap.set(node.value, node.filePath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (node.children) {\r\n\t\t\t\tfor (const child of node.children) {\r\n\t\t\t\t\tqueue.add(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tnewPlan.set(rootNode.filePath, map);\r\n\t}\r\n\treturn newPlan;\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,CAACC,IAAD,EAAOC,KAAP,KAAiB;EACjC,MAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB,CADiC,CAEjC;;EACA,KAAK,MAAM,CAACC,QAAD,EAAWC,KAAX,CAAX,IAAgCL,IAAhC,EAAsC;IACrCE,OAAO,CAACI,GAAR,CAAYF,QAAZ,EAAsB;MACrBA,QADqB;MAErBG,MAAM,EAAEC,SAFa;MAGrBC,QAAQ,EAAED,SAHW;MAIrBE,OAAO,EAAE,CAJY;MAKrBC,MAAM,EAAE,IALa;MAMrBN;IANqB,CAAtB;EAQA;;EACD,IAAIO,YAAY,GAAGV,OAAO,CAACW,IAA3B,CAbiC,CAcjC;;EACA,KAAK,MAAMC,IAAX,IAAmBZ,OAAO,CAACa,MAAR,EAAnB,EAAqC;IACpC,MAAMC,UAAU,GAAGpB,IAAI,CAACqB,OAAL,CAAaH,IAAI,CAACV,QAAlB,CAAnB;;IACA,IAAIY,UAAU,KAAKF,IAAI,CAACV,QAAxB,EAAkC;MACjC,IAAIG,MAAM,GAAGL,OAAO,CAACgB,GAAR,CAAYF,UAAZ,CAAb;;MACA,IAAIT,MAAM,KAAKC,SAAf,EAA0B;QACzBD,MAAM,GAAG;UACRH,QAAQ,EAAEY,UADF;UAERT,MAAM,EAAEC,SAFA;UAGRC,QAAQ,EAAE,CAACK,IAAD,CAHF;UAIRJ,OAAO,EAAEI,IAAI,CAACJ,OAJN;UAKRC,MAAM,EAAE,KALA;UAMRN,KAAK,EAAEG;QANC,CAAT;QAQAN,OAAO,CAACI,GAAR,CAAYU,UAAZ,EAAwBT,MAAxB;QACAO,IAAI,CAACP,MAAL,GAAcA,MAAd;MACA,CAXD,MAWO;QACNO,IAAI,CAACP,MAAL,GAAcA,MAAd;;QACA,IAAIA,MAAM,CAACE,QAAP,KAAoBD,SAAxB,EAAmC;UAClCD,MAAM,CAACE,QAAP,GAAkB,CAACK,IAAD,CAAlB;QACA,CAFD,MAEO;UACNP,MAAM,CAACE,QAAP,CAAgBU,IAAhB,CAAqBL,IAArB;QACA;;QACD,GAAG;UACFP,MAAM,CAACG,OAAP,IAAkBI,IAAI,CAACJ,OAAvB;UACAH,MAAM,GAAGA,MAAM,CAACA,MAAhB;QACA,CAHD,QAGSA,MAHT;MAIA;IACD;EACD,CA3CgC,CA4CjC;;;EACA,OAAOK,YAAY,GAAGX,KAAtB,EAA6B;IAC5B;IACA,MAAMmB,SAAS,GAAGR,YAAY,GAAGX,KAAjC;IACA,IAAIoB,QAAQ,GAAGb,SAAf;IACA,IAAIc,QAAQ,GAAGC,QAAf;;IACA,KAAK,MAAMT,IAAX,IAAmBZ,OAAO,CAACa,MAAR,EAAnB,EAAqC;MACpC,IAAID,IAAI,CAACJ,OAAL,IAAgB,CAAhB,IAAqB,CAACI,IAAI,CAACL,QAA3B,IAAuC,CAACK,IAAI,CAACP,MAAjD,EAAyD;MACzD,IAAIO,IAAI,CAACL,QAAL,CAAce,MAAd,KAAyB,CAA7B,EAAgC;MAChC,IAAIV,IAAI,CAACL,QAAL,CAAce,MAAd,KAAyB,CAAzB,IAA8B,CAACV,IAAI,CAACT,KAAxC,EAA+C,SAHX,CAIpC;MACA;MACA;;MACA,MAAMoB,IAAI,GACTX,IAAI,CAACJ,OAAL,GAAe,CAAf,IAAoBU,SAApB,GACGN,IAAI,CAACJ,OAAL,GAAe,CAAf,GAAmBU,SADtB,GAEGA,SAAS,GAAGN,IAAI,CAACJ,OAAjB,GAA2B,CAA3B,GAA+BT,KAAK,GAAG,GAH3C;;MAIA,IAAIwB,IAAI,GAAGH,QAAX,EAAqB;QACpBD,QAAQ,GAAGP,IAAX;QACAQ,QAAQ,GAAGG,IAAX;MACA;IACD;;IACD,IAAI,CAACJ,QAAL,EAAe,MArBa,CAsB5B;;IACA,MAAMK,SAAS,GAAGL,QAAQ,CAACX,OAAT,GAAmB,CAArC;IACAW,QAAQ,CAACV,MAAT,GAAkB,IAAlB;IACAU,QAAQ,CAACX,OAAT,GAAmB,CAAnB;IACAE,YAAY,IAAIc,SAAhB;IACA,IAAInB,MAAM,GAAGc,QAAQ,CAACd,MAAtB;;IACA,OAAOA,MAAP,EAAe;MACdA,MAAM,CAACG,OAAP,IAAkBgB,SAAlB;MACAnB,MAAM,GAAGA,MAAM,CAACA,MAAhB;IACA;;IACD,MAAMoB,KAAK,GAAG,IAAIC,GAAJ,CAAQP,QAAQ,CAACZ,QAAjB,CAAd;;IACA,KAAK,MAAMK,IAAX,IAAmBa,KAAnB,EAA0B;MACzBb,IAAI,CAACH,MAAL,GAAc,KAAd;MACAG,IAAI,CAACJ,OAAL,GAAe,CAAf;;MACA,IAAII,IAAI,CAACL,QAAT,EAAmB;QAClB,KAAK,MAAMoB,KAAX,IAAoBf,IAAI,CAACL,QAAzB,EAAmCkB,KAAK,CAACG,GAAN,CAAUD,KAAV;MACnC;IACD;EACD,CArFgC,CAsFjC;;;EACA,MAAME,OAAO,GAAG,IAAI5B,GAAJ,EAAhB;;EACA,KAAK,MAAM6B,QAAX,IAAuB9B,OAAO,CAACa,MAAR,EAAvB,EAAyC;IACxC,IAAI,CAACiB,QAAQ,CAACrB,MAAd,EAAsB;IACtB,MAAMsB,GAAG,GAAG,IAAI9B,GAAJ,EAAZ;IACA,MAAMwB,KAAK,GAAG,IAAIC,GAAJ,CAAQ,CAACI,QAAD,CAAR,CAAd;;IACA,KAAK,MAAMlB,IAAX,IAAmBa,KAAnB,EAA0B;MACzB,IAAIb,IAAI,CAACH,MAAL,IAAeG,IAAI,KAAKkB,QAA5B,EAAsC;;MACtC,IAAIlB,IAAI,CAACT,KAAT,EAAgB;QACf,IAAI6B,KAAK,CAACC,OAAN,CAAcrB,IAAI,CAACT,KAAnB,CAAJ,EAA+B;UAC9B,KAAK,MAAM+B,IAAX,IAAmBtB,IAAI,CAACT,KAAxB,EAA+B;YAC9B4B,GAAG,CAAC3B,GAAJ,CAAQ8B,IAAR,EAActB,IAAI,CAACV,QAAnB;UACA;QACD,CAJD,MAIO;UACN6B,GAAG,CAAC3B,GAAJ,CAAQQ,IAAI,CAACT,KAAb,EAAoBS,IAAI,CAACV,QAAzB;QACA;MACD;;MACD,IAAIU,IAAI,CAACL,QAAT,EAAmB;QAClB,KAAK,MAAMoB,KAAX,IAAoBf,IAAI,CAACL,QAAzB,EAAmC;UAClCkB,KAAK,CAACG,GAAN,CAAUD,KAAV;QACA;MACD;IACD;;IACDE,OAAO,CAACzB,GAAR,CAAY0B,QAAQ,CAAC5B,QAArB,EAA+B6B,GAA/B;EACA;;EACD,OAAOF,OAAP;AACA,CAhHD"},"metadata":{},"sourceType":"script"}