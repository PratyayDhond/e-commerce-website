{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\n\nconst RawSource = require(\"./RawSource\");\n\nconst streamChunks = require(\"./helpers/streamChunks\");\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n  constructor() {\n    super();\n    this._children = [];\n\n    for (let i = 0; i < arguments.length; i++) {\n      const item = arguments[i];\n\n      if (item instanceof ConcatSource) {\n        for (const child of item._children) {\n          this._children.push(child);\n        }\n      } else {\n        this._children.push(item);\n      }\n    }\n\n    this._isOptimized = arguments.length === 0;\n  }\n\n  getChildren() {\n    if (!this._isOptimized) this._optimize();\n    return this._children;\n  }\n\n  add(item) {\n    if (item instanceof ConcatSource) {\n      for (const child of item._children) {\n        this._children.push(child);\n      }\n    } else {\n      this._children.push(item);\n    }\n\n    this._isOptimized = false;\n  }\n\n  addAllSkipOptimizing(items) {\n    for (const item of items) {\n      this._children.push(item);\n    }\n  }\n\n  buffer() {\n    if (!this._isOptimized) this._optimize();\n    const buffers = [];\n\n    for (const child of this._children) {\n      if (typeof child.buffer === \"function\") {\n        buffers.push(child.buffer());\n      } else {\n        const bufferOrString = child.source();\n\n        if (Buffer.isBuffer(bufferOrString)) {\n          buffers.push(bufferOrString);\n        } else {\n          // This will not happen\n          buffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n        }\n      }\n    }\n\n    return Buffer.concat(buffers);\n  }\n\n  source() {\n    if (!this._isOptimized) this._optimize();\n    let source = \"\";\n\n    for (const child of this._children) {\n      source += child.source();\n    }\n\n    return source;\n  }\n\n  size() {\n    if (!this._isOptimized) this._optimize();\n    let size = 0;\n\n    for (const child of this._children) {\n      size += child.size();\n    }\n\n    return size;\n  }\n\n  map(options) {\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    if (!this._isOptimized) this._optimize();\n    if (this._children.length === 1) return this._children[0].streamChunks(options, onChunk, onSource, onName);\n    let currentLineOffset = 0;\n    let currentColumnOffset = 0;\n    let sourceMapping = new Map();\n    let nameMapping = new Map();\n    const finalSource = !!(options && options.finalSource);\n    let code = \"\";\n    let needToCloseMapping = false;\n\n    for (const item of this._children) {\n      const sourceIndexMapping = [];\n      const nameIndexMapping = [];\n      let lastMappingLine = 0;\n      const {\n        generatedLine,\n        generatedColumn,\n        source\n      } = streamChunks(item, options, // eslint-disable-next-line no-loop-func\n      (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n        const line = generatedLine + currentLineOffset;\n        const column = generatedLine === 1 ? generatedColumn + currentColumnOffset : generatedColumn;\n\n        if (needToCloseMapping) {\n          if (generatedLine !== 1 || generatedColumn !== 0) {\n            onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          }\n\n          needToCloseMapping = false;\n        }\n\n        const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n        const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];\n        lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\n        if (finalSource) {\n          if (chunk !== undefined) code += chunk;\n\n          if (resultSourceIndex >= 0) {\n            onChunk(undefined, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        } else {\n          if (resultSourceIndex < 0) {\n            onChunk(chunk, line, column, -1, -1, -1, -1);\n          } else {\n            onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        }\n      }, (i, source, sourceContent) => {\n        let globalIndex = sourceMapping.get(source);\n\n        if (globalIndex === undefined) {\n          sourceMapping.set(source, globalIndex = sourceMapping.size);\n          onSource(globalIndex, source, sourceContent);\n        }\n\n        sourceIndexMapping[i] = globalIndex;\n      }, (i, name) => {\n        let globalIndex = nameMapping.get(name);\n\n        if (globalIndex === undefined) {\n          nameMapping.set(name, globalIndex = nameMapping.size);\n          onName(globalIndex, name);\n        }\n\n        nameIndexMapping[i] = globalIndex;\n      });\n      if (source !== undefined) code += source;\n\n      if (needToCloseMapping) {\n        if (generatedLine !== 1 || generatedColumn !== 0) {\n          onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          needToCloseMapping = false;\n        }\n      }\n\n      if (generatedLine > 1) {\n        currentColumnOffset = generatedColumn;\n      } else {\n        currentColumnOffset += generatedColumn;\n      }\n\n      needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;\n      currentLineOffset += generatedLine - 1;\n    }\n\n    return {\n      generatedLine: currentLineOffset + 1,\n      generatedColumn: currentColumnOffset,\n      source: finalSource ? code : undefined\n    };\n  }\n\n  updateHash(hash) {\n    if (!this._isOptimized) this._optimize();\n    hash.update(\"ConcatSource\");\n\n    for (const item of this._children) {\n      item.updateHash(hash);\n    }\n  }\n\n  _optimize() {\n    const newChildren = [];\n    let currentString = undefined;\n    let currentRawSources = undefined;\n\n    const addStringToRawSources = string => {\n      if (currentRawSources === undefined) {\n        currentRawSources = string;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(string);\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), string];\n      }\n    };\n\n    const addSourceToRawSources = source => {\n      if (currentRawSources === undefined) {\n        currentRawSources = source;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(source.source());\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), source.source()];\n      }\n    };\n\n    const mergeRawSources = () => {\n      if (Array.isArray(currentRawSources)) {\n        const rawSource = new RawSource(currentRawSources.join(\"\"));\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else if (typeof currentRawSources === \"string\") {\n        const rawSource = new RawSource(currentRawSources);\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else {\n        newChildren.push(currentRawSources);\n      }\n    };\n\n    for (const child of this._children) {\n      if (typeof child === \"string\") {\n        if (currentString === undefined) {\n          currentString = child;\n        } else {\n          currentString += child;\n        }\n      } else {\n        if (currentString !== undefined) {\n          addStringToRawSources(currentString);\n          currentString = undefined;\n        }\n\n        if (stringsAsRawSources.has(child)) {\n          addSourceToRawSources(child);\n        } else {\n          if (currentRawSources !== undefined) {\n            mergeRawSources();\n            currentRawSources = undefined;\n          }\n\n          newChildren.push(child);\n        }\n      }\n    }\n\n    if (currentString !== undefined) {\n      addStringToRawSources(currentString);\n    }\n\n    if (currentRawSources !== undefined) {\n      mergeRawSources();\n    }\n\n    this._children = newChildren;\n    this._isOptimized = true;\n  }\n\n}\n\nmodule.exports = ConcatSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","stringsAsRawSources","WeakSet","ConcatSource","constructor","_children","i","arguments","length","item","child","push","_isOptimized","getChildren","_optimize","add","addAllSkipOptimizing","items","buffer","buffers","bufferOrString","source","Buffer","isBuffer","from","concat","size","map","options","sourceAndMap","onChunk","onSource","onName","currentLineOffset","currentColumnOffset","sourceMapping","Map","nameMapping","finalSource","code","needToCloseMapping","sourceIndexMapping","nameIndexMapping","lastMappingLine","generatedLine","generatedColumn","chunk","sourceIndex","originalLine","originalColumn","nameIndex","line","column","undefined","resultSourceIndex","resultNameIndex","sourceContent","globalIndex","get","set","name","updateHash","hash","update","newChildren","currentString","currentRawSources","addStringToRawSources","string","Array","isArray","addSourceToRawSources","mergeRawSources","rawSource","join","has","module","exports"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/webpack-sources/lib/ConcatSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst Source = require(\"./Source\");\r\nconst RawSource = require(\"./RawSource\");\r\nconst streamChunks = require(\"./helpers/streamChunks\");\r\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\r\n\r\nconst stringsAsRawSources = new WeakSet();\r\n\r\nclass ConcatSource extends Source {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis._children = [];\r\n\t\tfor (let i = 0; i < arguments.length; i++) {\r\n\t\t\tconst item = arguments[i];\r\n\t\t\tif (item instanceof ConcatSource) {\r\n\t\t\t\tfor (const child of item._children) {\r\n\t\t\t\t\tthis._children.push(child);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis._children.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._isOptimized = arguments.length === 0;\r\n\t}\r\n\r\n\tgetChildren() {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\treturn this._children;\r\n\t}\r\n\r\n\tadd(item) {\r\n\t\tif (item instanceof ConcatSource) {\r\n\t\t\tfor (const child of item._children) {\r\n\t\t\t\tthis._children.push(child);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._children.push(item);\r\n\t\t}\r\n\t\tthis._isOptimized = false;\r\n\t}\r\n\r\n\taddAllSkipOptimizing(items) {\r\n\t\tfor (const item of items) {\r\n\t\t\tthis._children.push(item);\r\n\t\t}\r\n\t}\r\n\r\n\tbuffer() {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\tconst buffers = [];\r\n\t\tfor (const child of this._children) {\r\n\t\t\tif (typeof child.buffer === \"function\") {\r\n\t\t\t\tbuffers.push(child.buffer());\r\n\t\t\t} else {\r\n\t\t\t\tconst bufferOrString = child.source();\r\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\r\n\t\t\t\t\tbuffers.push(bufferOrString);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// This will not happen\r\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Buffer.concat(buffers);\r\n\t}\r\n\r\n\tsource() {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\tlet source = \"\";\r\n\t\tfor (const child of this._children) {\r\n\t\t\tsource += child.source();\r\n\t\t}\r\n\t\treturn source;\r\n\t}\r\n\r\n\tsize() {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\tlet size = 0;\r\n\t\tfor (const child of this._children) {\r\n\t\t\tsize += child.size();\r\n\t\t}\r\n\t\treturn size;\r\n\t}\r\n\r\n\tmap(options) {\r\n\t\treturn getMap(this, options);\r\n\t}\r\n\r\n\tsourceAndMap(options) {\r\n\t\treturn getSourceAndMap(this, options);\r\n\t}\r\n\r\n\tstreamChunks(options, onChunk, onSource, onName) {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\tif (this._children.length === 1)\r\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\r\n\t\tlet currentLineOffset = 0;\r\n\t\tlet currentColumnOffset = 0;\r\n\t\tlet sourceMapping = new Map();\r\n\t\tlet nameMapping = new Map();\r\n\t\tconst finalSource = !!(options && options.finalSource);\r\n\t\tlet code = \"\";\r\n\t\tlet needToCloseMapping = false;\r\n\t\tfor (const item of this._children) {\r\n\t\t\tconst sourceIndexMapping = [];\r\n\t\t\tconst nameIndexMapping = [];\r\n\t\t\tlet lastMappingLine = 0;\r\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\r\n\t\t\t\titem,\r\n\t\t\t\toptions,\r\n\t\t\t\t// eslint-disable-next-line no-loop-func\r\n\t\t\t\t(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tgeneratedLine,\r\n\t\t\t\t\tgeneratedColumn,\r\n\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\toriginalLine,\r\n\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\tnameIndex\r\n\t\t\t\t) => {\r\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\r\n\t\t\t\t\tconst column =\r\n\t\t\t\t\t\tgeneratedLine === 1\r\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\r\n\t\t\t\t\t\t\t: generatedColumn;\r\n\t\t\t\t\tif (needToCloseMapping) {\r\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\r\n\t\t\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\r\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\r\n\t\t\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t\t\t-1\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tneedToCloseMapping = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst resultSourceIndex =\r\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\r\n\t\t\t\t\t\t\t? -1\r\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\r\n\t\t\t\t\tconst resultNameIndex =\r\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\r\n\t\t\t\t\t\t\t? -1\r\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\r\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\r\n\t\t\t\t\tif (finalSource) {\r\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\r\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\r\n\t\t\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\t\tline,\r\n\t\t\t\t\t\t\t\tcolumn,\r\n\t\t\t\t\t\t\t\tresultSourceIndex,\r\n\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\tresultNameIndex\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\r\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\t\t\tchunk,\r\n\t\t\t\t\t\t\t\tline,\r\n\t\t\t\t\t\t\t\tcolumn,\r\n\t\t\t\t\t\t\t\tresultSourceIndex,\r\n\t\t\t\t\t\t\t\toriginalLine,\r\n\t\t\t\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\t\t\t\tresultNameIndex\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t(i, source, sourceContent) => {\r\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\r\n\t\t\t\t\tif (globalIndex === undefined) {\r\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\r\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\r\n\t\t\t\t},\r\n\t\t\t\t(i, name) => {\r\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\r\n\t\t\t\t\tif (globalIndex === undefined) {\r\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\r\n\t\t\t\t\t\tonName(globalIndex, name);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tif (source !== undefined) code += source;\r\n\t\t\tif (needToCloseMapping) {\r\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\r\n\t\t\t\t\tonChunk(\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tcurrentLineOffset + 1,\r\n\t\t\t\t\t\tcurrentColumnOffset,\r\n\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t-1,\r\n\t\t\t\t\t\t-1\r\n\t\t\t\t\t);\r\n\t\t\t\t\tneedToCloseMapping = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (generatedLine > 1) {\r\n\t\t\t\tcurrentColumnOffset = generatedColumn;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentColumnOffset += generatedColumn;\r\n\t\t\t}\r\n\t\t\tneedToCloseMapping =\r\n\t\t\t\tneedToCloseMapping ||\r\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\r\n\t\t\tcurrentLineOffset += generatedLine - 1;\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tgeneratedLine: currentLineOffset + 1,\r\n\t\t\tgeneratedColumn: currentColumnOffset,\r\n\t\t\tsource: finalSource ? code : undefined\r\n\t\t};\r\n\t}\r\n\r\n\tupdateHash(hash) {\r\n\t\tif (!this._isOptimized) this._optimize();\r\n\t\thash.update(\"ConcatSource\");\r\n\t\tfor (const item of this._children) {\r\n\t\t\titem.updateHash(hash);\r\n\t\t}\r\n\t}\r\n\r\n\t_optimize() {\r\n\t\tconst newChildren = [];\r\n\t\tlet currentString = undefined;\r\n\t\tlet currentRawSources = undefined;\r\n\t\tconst addStringToRawSources = string => {\r\n\t\t\tif (currentRawSources === undefined) {\r\n\t\t\t\tcurrentRawSources = string;\r\n\t\t\t} else if (Array.isArray(currentRawSources)) {\r\n\t\t\t\tcurrentRawSources.push(string);\r\n\t\t\t} else {\r\n\t\t\t\tcurrentRawSources = [\r\n\t\t\t\t\ttypeof currentRawSources === \"string\"\r\n\t\t\t\t\t\t? currentRawSources\r\n\t\t\t\t\t\t: currentRawSources.source(),\r\n\t\t\t\t\tstring\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst addSourceToRawSources = source => {\r\n\t\t\tif (currentRawSources === undefined) {\r\n\t\t\t\tcurrentRawSources = source;\r\n\t\t\t} else if (Array.isArray(currentRawSources)) {\r\n\t\t\t\tcurrentRawSources.push(source.source());\r\n\t\t\t} else {\r\n\t\t\t\tcurrentRawSources = [\r\n\t\t\t\t\ttypeof currentRawSources === \"string\"\r\n\t\t\t\t\t\t? currentRawSources\r\n\t\t\t\t\t\t: currentRawSources.source(),\r\n\t\t\t\t\tsource.source()\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst mergeRawSources = () => {\r\n\t\t\tif (Array.isArray(currentRawSources)) {\r\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\r\n\t\t\t\tstringsAsRawSources.add(rawSource);\r\n\t\t\t\tnewChildren.push(rawSource);\r\n\t\t\t} else if (typeof currentRawSources === \"string\") {\r\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\r\n\t\t\t\tstringsAsRawSources.add(rawSource);\r\n\t\t\t\tnewChildren.push(rawSource);\r\n\t\t\t} else {\r\n\t\t\t\tnewChildren.push(currentRawSources);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfor (const child of this._children) {\r\n\t\t\tif (typeof child === \"string\") {\r\n\t\t\t\tif (currentString === undefined) {\r\n\t\t\t\t\tcurrentString = child;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentString += child;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (currentString !== undefined) {\r\n\t\t\t\t\taddStringToRawSources(currentString);\r\n\t\t\t\t\tcurrentString = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (stringsAsRawSources.has(child)) {\r\n\t\t\t\t\taddSourceToRawSources(child);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (currentRawSources !== undefined) {\r\n\t\t\t\t\t\tmergeRawSources();\r\n\t\t\t\t\t\tcurrentRawSources = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewChildren.push(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (currentString !== undefined) {\r\n\t\t\taddStringToRawSources(currentString);\r\n\t\t}\r\n\t\tif (currentRawSources !== undefined) {\r\n\t\t\tmergeRawSources();\r\n\t\t}\r\n\t\tthis._children = newChildren;\r\n\t\tthis._isOptimized = true;\r\n\t}\r\n}\r\n\r\nmodule.exports = ConcatSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}