{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Ivan Kopeykin @vankop\r\n*/\n\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst path = require(\"path\");\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nconst forEachBail = require(\"./forEachBail\");\n\nconst {\n  processExportsField\n} = require(\"./util/entrypoints\");\n\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\n\nconst {\n  checkExportsFieldTarget\n} = require(\"./util/path\");\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\n\nmodule.exports = class ExportsFieldPlugin {\n  /**\r\n   * @param {string | ResolveStepHook} source source\r\n   * @param {Set<string>} conditionNames condition names\r\n   * @param {string | string[]} fieldNamePath name path\r\n   * @param {string | ResolveStepHook} target target\r\n   */\n  constructor(source, conditionNames, fieldNamePath, target) {\n    this.source = source;\n    this.target = target;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<any, FieldProcessor>} */\n\n    this.fieldProcessorCache = new WeakMap();\n  }\n  /**\r\n   * @param {Resolver} resolver the resolver\r\n   * @returns {void}\r\n   */\n\n\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    resolver.getHook(this.source).tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath) return callback();\n      if ( // When the description file is inherited from parent, abort\n      // (There is no description file inside of this package)\n      request.relativePath !== \".\" || request.request === undefined) return callback();\n      const remainingRequest = request.query || request.fragment ? (request.request === \".\" ? \"./\" : request.request) + request.query + request.fragment : request.request;\n      /** @type {ExportsField|null} */\n\n      const exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);\n      if (!exportsField) return callback();\n\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));\n      }\n\n      let paths;\n\n      try {\n        // We attach the cache to the description file instead of the exportsField value\n        // because we use a WeakMap and the exportsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);\n\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processExportsField(exportsField);\n          this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);\n        }\n\n        paths = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch (err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n\n        return callback(err);\n      }\n\n      if (paths.length === 0) {\n        return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));\n      }\n\n      forEachBail(paths, (p, callback) => {\n        const parsedIdentifier = parseIdentifier(p);\n        if (!parsedIdentifier) return callback();\n        const [relativePath, query, fragment] = parsedIdentifier;\n        const error = checkExportsFieldTarget(relativePath);\n\n        if (error) {\n          return callback(error);\n        }\n\n        const obj = { ...request,\n          request: undefined,\n          path: path.join(\n          /** @type {string} */\n          request.descriptionFileRoot, relativePath),\n          relativePath,\n          query,\n          fragment\n        };\n        resolver.doResolve(target, obj, \"using exports field: \" + p, resolveContext, callback);\n      }, (err, result) => callback(err, result || null));\n    });\n  }\n\n};","map":{"version":3,"names":["path","require","DescriptionFileUtils","forEachBail","processExportsField","parseIdentifier","checkExportsFieldTarget","module","exports","ExportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","target","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","relativePath","undefined","remainingRequest","query","fragment","exportsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","error","obj","join","doResolve","result"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Ivan Kopeykin @vankop\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst path = require(\"path\");\r\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\r\nconst forEachBail = require(\"./forEachBail\");\r\nconst { processExportsField } = require(\"./util/entrypoints\");\r\nconst { parseIdentifier } = require(\"./util/identifier\");\r\nconst { checkExportsFieldTarget } = require(\"./util/path\");\r\n\r\n/** @typedef {import(\"./Resolver\")} Resolver */\r\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\r\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\r\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\r\n\r\nmodule.exports = class ExportsFieldPlugin {\r\n\t/**\r\n\t * @param {string | ResolveStepHook} source source\r\n\t * @param {Set<string>} conditionNames condition names\r\n\t * @param {string | string[]} fieldNamePath name path\r\n\t * @param {string | ResolveStepHook} target target\r\n\t */\r\n\tconstructor(source, conditionNames, fieldNamePath, target) {\r\n\t\tthis.source = source;\r\n\t\tthis.target = target;\r\n\t\tthis.conditionNames = conditionNames;\r\n\t\tthis.fieldName = fieldNamePath;\r\n\t\t/** @type {WeakMap<any, FieldProcessor>} */\r\n\t\tthis.fieldProcessorCache = new WeakMap();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Resolver} resolver the resolver\r\n\t * @returns {void}\r\n\t */\r\n\tapply(resolver) {\r\n\t\tconst target = resolver.ensureHook(this.target);\r\n\t\tresolver\r\n\t\t\t.getHook(this.source)\r\n\t\t\t.tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\r\n\t\t\t\t// When there is no description file, abort\r\n\t\t\t\tif (!request.descriptionFilePath) return callback();\r\n\t\t\t\tif (\r\n\t\t\t\t\t// When the description file is inherited from parent, abort\r\n\t\t\t\t\t// (There is no description file inside of this package)\r\n\t\t\t\t\trequest.relativePath !== \".\" ||\r\n\t\t\t\t\trequest.request === undefined\r\n\t\t\t\t)\r\n\t\t\t\t\treturn callback();\r\n\r\n\t\t\t\tconst remainingRequest =\r\n\t\t\t\t\trequest.query || request.fragment\r\n\t\t\t\t\t\t? (request.request === \".\" ? \"./\" : request.request) +\r\n\t\t\t\t\t\t  request.query +\r\n\t\t\t\t\t\t  request.fragment\r\n\t\t\t\t\t\t: request.request;\r\n\t\t\t\t/** @type {ExportsField|null} */\r\n\t\t\t\tconst exportsField = DescriptionFileUtils.getField(\r\n\t\t\t\t\trequest.descriptionFileData,\r\n\t\t\t\t\tthis.fieldName\r\n\t\t\t\t);\r\n\t\t\t\tif (!exportsField) return callback();\r\n\r\n\t\t\t\tif (request.directory) {\r\n\t\t\t\t\treturn callback(\r\n\t\t\t\t\t\tnew Error(\r\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet paths;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// We attach the cache to the description file instead of the exportsField value\r\n\t\t\t\t\t// because we use a WeakMap and the exportsField could be a string too.\r\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\r\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\r\n\t\t\t\t\t\trequest.descriptionFileData\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (fieldProcessor === undefined) {\r\n\t\t\t\t\t\tfieldProcessor = processExportsField(exportsField);\r\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\r\n\t\t\t\t\t\t\trequest.descriptionFileData,\r\n\t\t\t\t\t\t\tfieldProcessor\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tif (resolveContext.log) {\r\n\t\t\t\t\t\tresolveContext.log(\r\n\t\t\t\t\t\t\t`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn callback(err);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (paths.length === 0) {\r\n\t\t\t\t\treturn callback(\r\n\t\t\t\t\t\tnew Error(\r\n\t\t\t\t\t\t\t`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tforEachBail(\r\n\t\t\t\t\tpaths,\r\n\t\t\t\t\t(p, callback) => {\r\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\r\n\r\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\r\n\r\n\t\t\t\t\t\tconst [relativePath, query, fragment] = parsedIdentifier;\r\n\r\n\t\t\t\t\t\tconst error = checkExportsFieldTarget(relativePath);\r\n\r\n\t\t\t\t\t\tif (error) {\r\n\t\t\t\t\t\t\treturn callback(error);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst obj = {\r\n\t\t\t\t\t\t\t...request,\r\n\t\t\t\t\t\t\trequest: undefined,\r\n\t\t\t\t\t\t\tpath: path.join(\r\n\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\r\n\t\t\t\t\t\t\t\trelativePath\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t\trelativePath,\r\n\t\t\t\t\t\t\tquery,\r\n\t\t\t\t\t\t\tfragment\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tresolver.doResolve(\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tobj,\r\n\t\t\t\t\t\t\t\"using exports field: \" + p,\r\n\t\t\t\t\t\t\tresolveContext,\r\n\t\t\t\t\t\t\tcallback\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t},\r\n\t\t\t\t\t(err, result) => callback(err, result || null)\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}