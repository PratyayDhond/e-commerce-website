{"ast":null,"code":"\"use strict\";\n/**\r\n * @typedef {[number, boolean]} RangeValue\r\n */\n\n/**\r\n * @callback RangeValueCallback\r\n * @param {RangeValue} rangeValue\r\n * @returns {boolean}\r\n */\n\nclass Range {\n  /**\r\n   * @param {\"left\" | \"right\"} side\r\n   * @param {boolean} exclusive\r\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\r\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\r\n   * @param {number} value\r\n   * @param {boolean} logic is not logic applied\r\n   * @param {boolean} exclusive is range exclusive\r\n   * @returns {string}\r\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\r\n   * @param {number} value\r\n   * @param {boolean} logic is not logic applied\r\n   * @param {boolean} exclusive is range exclusive\r\n   * @returns {string}\r\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\r\n   * @param {number} start left side value\r\n   * @param {number} end right side value\r\n   * @param {boolean} startExclusive is range exclusive from left side\r\n   * @param {boolean} endExclusive is range exclusive from right side\r\n   * @param {boolean} logic is not logic applied\r\n   * @returns {string}\r\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\r\n   * @param {Array<RangeValue>} values\r\n   * @param {boolean} logic is not logic applied\r\n   * @return {RangeValue} computed value and it's exclusive flag\r\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\r\n   * @param {number} value\r\n   * @param {boolean=} exclusive\r\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\r\n   * @param {number} value\r\n   * @param {boolean=} exclusive\r\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\r\n   * @param {boolean} logic is not logic applied\r\n   * @return {string} \"smart\" range string representation\r\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;","map":{"version":3,"names":["Range","getOperator","side","exclusive","formatRight","value","logic","formatLeft","formatRange","start","end","startExclusive","endExclusive","result","getRangeValue","values","minMax","Infinity","j","predicate","i","length","constructor","_left","_right","left","push","right","format","leftExclusive","rightExclusive","Number","isFinite","realStart","realEnd","module","exports"],"sources":["W:/Coding/finalProject/e-commerce-website/node_modules/terser-webpack-plugin/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * @typedef {[number, boolean]} RangeValue\r\n */\r\n\r\n/**\r\n * @callback RangeValueCallback\r\n * @param {RangeValue} rangeValue\r\n * @returns {boolean}\r\n */\r\nclass Range {\r\n  /**\r\n   * @param {\"left\" | \"right\"} side\r\n   * @param {boolean} exclusive\r\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\r\n   */\r\n  static getOperator(side, exclusive) {\r\n    if (side === \"left\") {\r\n      return exclusive ? \">\" : \">=\";\r\n    }\r\n\r\n    return exclusive ? \"<\" : \"<=\";\r\n  }\r\n  /**\r\n   * @param {number} value\r\n   * @param {boolean} logic is not logic applied\r\n   * @param {boolean} exclusive is range exclusive\r\n   * @returns {string}\r\n   */\r\n\r\n\r\n  static formatRight(value, logic, exclusive) {\r\n    if (logic === false) {\r\n      return Range.formatLeft(value, !logic, !exclusive);\r\n    }\r\n\r\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\r\n  }\r\n  /**\r\n   * @param {number} value\r\n   * @param {boolean} logic is not logic applied\r\n   * @param {boolean} exclusive is range exclusive\r\n   * @returns {string}\r\n   */\r\n\r\n\r\n  static formatLeft(value, logic, exclusive) {\r\n    if (logic === false) {\r\n      return Range.formatRight(value, !logic, !exclusive);\r\n    }\r\n\r\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\r\n  }\r\n  /**\r\n   * @param {number} start left side value\r\n   * @param {number} end right side value\r\n   * @param {boolean} startExclusive is range exclusive from left side\r\n   * @param {boolean} endExclusive is range exclusive from right side\r\n   * @param {boolean} logic is not logic applied\r\n   * @returns {string}\r\n   */\r\n\r\n\r\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\r\n    let result = \"should be\";\r\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\r\n    result += logic ? \"and\" : \"or\";\r\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\r\n    return result;\r\n  }\r\n  /**\r\n   * @param {Array<RangeValue>} values\r\n   * @param {boolean} logic is not logic applied\r\n   * @return {RangeValue} computed value and it's exclusive flag\r\n   */\r\n\r\n\r\n  static getRangeValue(values, logic) {\r\n    let minMax = logic ? Infinity : -Infinity;\r\n    let j = -1;\r\n    const predicate = logic ?\r\n    /** @type {RangeValueCallback} */\r\n    ([value]) => value <= minMax :\r\n    /** @type {RangeValueCallback} */\r\n    ([value]) => value >= minMax;\r\n\r\n    for (let i = 0; i < values.length; i++) {\r\n      if (predicate(values[i])) {\r\n        [minMax] = values[i];\r\n        j = i;\r\n      }\r\n    }\r\n\r\n    if (j > -1) {\r\n      return values[j];\r\n    }\r\n\r\n    return [Infinity, true];\r\n  }\r\n\r\n  constructor() {\r\n    /** @type {Array<RangeValue>} */\r\n    this._left = [];\r\n    /** @type {Array<RangeValue>} */\r\n\r\n    this._right = [];\r\n  }\r\n  /**\r\n   * @param {number} value\r\n   * @param {boolean=} exclusive\r\n   */\r\n\r\n\r\n  left(value, exclusive = false) {\r\n    this._left.push([value, exclusive]);\r\n  }\r\n  /**\r\n   * @param {number} value\r\n   * @param {boolean=} exclusive\r\n   */\r\n\r\n\r\n  right(value, exclusive = false) {\r\n    this._right.push([value, exclusive]);\r\n  }\r\n  /**\r\n   * @param {boolean} logic is not logic applied\r\n   * @return {string} \"smart\" range string representation\r\n   */\r\n\r\n\r\n  format(logic = true) {\r\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\r\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\r\n\r\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\r\n      return \"\";\r\n    }\r\n\r\n    const realStart = leftExclusive ? start + 1 : start;\r\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\r\n\r\n    if (realStart === realEnd) {\r\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\r\n    } // e.g. 4 < x < ∞\r\n\r\n\r\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\r\n      return Range.formatLeft(start, logic, leftExclusive);\r\n    } // e.g. ∞ < x < 4\r\n\r\n\r\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\r\n      return Range.formatRight(end, logic, rightExclusive);\r\n    }\r\n\r\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = Range;"],"mappings":"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"},"metadata":{},"sourceType":"script"}